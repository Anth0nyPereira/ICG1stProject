<!DOCTYPE html>

<html lang="en">
<!--

		Example adapted for Daniel Rohmer tutorial

		https://imagecomputing.net/damien.rohmer/teaching/2019_2020/semester_1/MPRI_2-39/practice/threejs/content/000_threejs_tutorial/index.html

		J. Madeira - April 2021

-->

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title> 3D scene </title>

    <link rel="stylesheet" href="style.css">

    <script type="module">

        import * as THREE from "https://threejs.org/build/three.module.js";

        import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";

        import { ConvexGeometry } from "https://threejs.org/examples/jsm/geometries/ConvexGeometry.js";

        // TO INITIALIZE

        const helper = {

            initEmptyScene: function (sceneElements) {

                // ************************** //
                // Create the 3D scene
                // ************************** //
                sceneElements.sceneGraph = new THREE.Scene();


                // ************************** //
                // Add camera
                // ************************** //
                const width = window.innerWidth;
                const height = window.innerHeight;
                const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 500);
                sceneElements.camera = camera;
                

                // position and point the camera to the center of the scene
        camera.position.x = -30;
        camera.position.y = 40;
        camera.position.z = 50;
        camera.lookAt(new THREE.Vector3(0, 5, 10));

                // ************************** //
                // Illumination
                // ************************** //

                // ************************** //
                // Add ambient light
                // ************************** //
                const ambientLight = new THREE.AmbientLight('rgb(255, 255, 255)', 0.2);
                sceneElements.sceneGraph.add(ambientLight);

                // ***************************** //
                // lights
                // ***************************** //
                var light = new THREE.DirectionalLight( 0xffffff );
        light.position.set( 0, 1, 1 ).normalize();
        sceneElements.sceneGraph.add(light);

        const alight = new THREE.AmbientLight( 0x404040 ); // soft white light
        sceneElements.sceneGraph.add( alight );

                // *********************************** //
                // Create renderer (with shadow map)
                // *********************************** //
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                sceneElements.renderer = renderer;
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setClearColor('rgb(255, 255, 150)', 1.0);
                renderer.setSize(width, height);

                // Setup shadowMap property
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;


                // **************************************** //
                // Add the rendered image in the HTML DOM
                // **************************************** //
                const htmlElement = document.querySelector("#Tag3DScene");
                htmlElement.appendChild(renderer.domElement);

                // ************************** //
                // NEW --- Control for the camera
                // ************************** //
                sceneElements.control = new OrbitControls(camera, renderer.domElement);
                sceneElements.control.screenSpacePanning = true;

            },

            render: function render(sceneElements) {
                sceneElements.renderer.render(sceneElements.sceneGraph, sceneElements.camera);
            },
        };

        // BUILDING THE SCENE
        // To store the scene graph, and elements usefull to rendering the scene
        const sceneElements = {
            sceneGraph: null,
            camera: null,
            control: null,  // NEW
            renderer: null,
        };


        // Functions are called
        //  1. Initialize the empty scene
        //  2. Add elements within the scene
        //  3. Animate
        function init() {
            helper.initEmptyScene(sceneElements);
            load3DObjects(sceneElements.sceneGraph);
            requestAnimationFrame(computeFrame);
        }

        // HANDLING EVENTS

        window.addEventListener('resize', resizeWindow);

        //To keep track of the keyboard - WASD
        var keyD = false, keyA = false, keyS = false, keyW = false, keyPlus = false, keyMinus = false, keyP = false, keyM = false;
        document.addEventListener('keydown', onDocumentKeyDown, false);
        document.addEventListener('keyup', onDocumentKeyUp, false);
        document.addEventListener('mousemove', onDocumentMouseMove, false);

        function onDocumentMouseMove(event)
{
    // the following line would stop any other event handler from firing
    // (such as the mouse's TrackballControls)
    event.preventDefault();

    // update the mouse variable
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

}

        // Update render image size and camera aspect when the window is resized
        function resizeWindow(eventParam) {
            const width = window.innerWidth;
            const height = window.innerHeight;

            sceneElements.camera.aspect = width / height;
            sceneElements.camera.updateProjectionMatrix();

            sceneElements.renderer.setSize(width, height);
        }

        function onDocumentKeyDown(event) {
            switch (event.keyCode) {
                case 68: //d
                    keyD = true;
                    break;
                case 83: //s
                    keyS = true;
                    break;
                case 65: //a
                    keyA = true;
                    break;
                case 87: //w
                    keyW = true;
                    break;
                case 187: //+
                    keyPlus = true;
                    break;
                case 189: //-
                    keyMinus = true;
                    break;
                case 80: //P 
                    keyP = true;
                    break;
                case 77: //M
                    keyM = true;
                    break;
            }
        }
        function onDocumentKeyUp(event) {
            switch (event.keyCode) {
                case 68: //d
                    keyD = false;
                    break;
                case 83: //s
                    keyS = false;
                    break;
                case 65: //a
                    keyA = false;
                    break;
                case 87: //w
                    keyW = false;
                    break;
                case 187: //+
                    keyPlus = false;
                    break;
                case 189: //-
                    keyMinus = false;
                    break;
                case 80: //P 
                    keyP = false;
                    break;
                case 77: //M
                    keyM = false;
                    break;
            }
    }
function makeCircle(color) {
    var radius =  1.0;  
    var tubeRadius =  5.0;  
    var radialSegments = 30;  
    var tubularSegments = 100;  
    var geometry = new THREE.TorusGeometry(radius, tubeRadius,radialSegments, tubularSegments);
    var material = new THREE.MeshBasicMaterial({color: color});
    var mesh = new THREE.Mesh(geometry, material);
    //mesh.scale.set(0.1, 0.1, 0.1);
    return mesh;
}

function makeSemiSphere() {
    const midSphereRadius =  5.8;  
    const widthSegments = 30;  
    const heightSegments = 30;  
    const phiStart = Math.PI * 0.68;  
    const phiLength = Math.PI * 1.06;  
    const thetaStart = Math.PI * 1.00;  
    const thetaLength = Math.PI * 0.46; 

    var midSphereGeometry = new THREE.SphereGeometry(
        midSphereRadius,
        widthSegments, heightSegments,
        phiStart, phiLength,
        thetaStart, thetaLength);
    
    var material = new THREE.MeshBasicMaterial({color: 0xffc0cb});
    var mesh = new THREE.Mesh(midSphereGeometry, material);
    return mesh;
    
}

function makeHair() {
    var hair = new THREE.Group();
    var geometry = new THREE.BoxGeometry( 0.5, 20, 8);
    var material = new THREE.MeshBasicMaterial( {color: 0xffc0cb} );
    var hair1 = new THREE.Mesh( geometry, material );

    var shape = new THREE.Shape();
    shape.moveTo(5,0);
    shape.lineTo(0, 10);
    shape.lineTo(-5, 0);
    shape.lineTo(5, 0);

    const extrudeSettings = {
        steps: 2,
        depth: 0.01,
        bevelEnabled: true,
        bevelThickness: 1,
        bevelSize: 1,
        bevelOffset: 0,
        bevelSegments: 1
};

var shapeGeometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
var shapeMaterial = new THREE.MeshBasicMaterial( { color: 0xffc0cb } );
var shapeHair = new THREE.Mesh( shapeGeometry, shapeMaterial ) ;
shapeHair.rotation.y = Math.PI/2;
shapeHair.scale.set(1, 1.8, 1.3);
shapeHair.position.y = -10;

hair.add(hair1);
hair.add(shapeHair);


    return hair;
}

function createHead() {
    var head = new THREE.Group();
    var circle = makeCircle(0xf7e7ce);
    var beginHair = makeCircle(0xffc0cb);
    beginHair.scale.set(0.9, 0.2, 1);
    beginHair.position.set(0, 5, -1);
    beginHair.rotation.x = -0.2;
    /*
    var beginHair = makeSemiSphere();
    beginHair.rotation.z = 3*Math.PI/2 + 0.2;
    beginHair.position.y = 10;
    beginHair.position.z = -4;
    */
    var hair = makeHair();
    hair.rotation.y = Math.PI/2;
    hair.position.z = -4.8;
    hair.position.y = -6;

    // eyebrows
    var eyeBrowsShape = new THREE.Shape();
    eyeBrowsShape.moveTo( 0,0 );
    eyeBrowsShape.lineTo(0.5, 1);
    eyeBrowsShape.lineTo(1.5, 3);
    eyeBrowsShape.lineTo(3.5, 3);
    eyeBrowsShape.lineTo(5, 1);
    eyeBrowsShape.lineTo(5.5, 0);
    eyeBrowsShape.lineTo(3.5, 3);
    eyeBrowsShape.lineTo(1.5, 3);
    eyeBrowsShape.lineTo(0, 0);

    var extrudeSettings = {
        steps: 2,
        depth: 0.01,
        bevelEnabled: true,
        bevelThickness: 1,
        bevelSize: 1,
        bevelOffset: 0,
        bevelSegments: 1
    };

    var eyeBrowsGeometry = new THREE.ExtrudeGeometry( eyeBrowsShape, extrudeSettings );
    var eyeBrowsMaterial = new THREE.MeshBasicMaterial( { color: 0x000000 } );
    var eyeBrow1 = new THREE.Mesh( eyeBrowsGeometry, eyeBrowsMaterial ) ;
    eyeBrow1.position.set(-4, 2.5, 4);
    eyeBrow1.rotation.y = -0.2;
    eyeBrow1.scale.set(0.3, 0.3, 0.3);

    var eyeBrow2 = new THREE.Mesh( eyeBrowsGeometry, eyeBrowsMaterial ) ;
    eyeBrow2.position.set(3, 2.5, 4);
    eyeBrow2.rotation.y = 0.2;
    eyeBrow2.scale.set(0.3, 0.3, 0.3);

    // mouth
    var mouthShape = new THREE.Shape();
    mouthShape.moveTo(-1, 0);
    mouthShape.lineTo(1, 0);
    mouthShape.bezierCurveTo(0.2, -0.1, -0.2, -0.1, -1, 0);

    var mouthGeometry = new THREE.ExtrudeGeometry( mouthShape, extrudeSettings );
    var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
    var mouthMaterial = new THREE.MeshBasicMaterial({color: randomColor})
    var mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
    mouth.scale.set(0.5, 2, 0.5);
    mouth.position.set(0, 0, 5);

    // band
    var bandGeometry = new THREE.BoxGeometry(8, 0.5, 1);
    var bandMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
    var band1 = new THREE.Mesh(bandGeometry, bandMaterial);
    band1.position.y = 6.2;

    // horns
    var hornRadius =  1.0;  
    var hornHeight = 10.0;  
    var hornRadialSegments =  3;  
    var hornGeometry = new THREE.ConeGeometry(hornRadius, hornHeight, hornRadialSegments);
    var hornMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
    var horn1 = new THREE.Mesh(hornGeometry, hornMaterial);
    horn1.scale.set(1, 0.5, 1);
    horn1.position.set(2, 7, 0);

    var horn2 = new THREE.Mesh(hornGeometry, hornMaterial);
    horn2.scale.set(1, 0.5, 1);
    horn2.position.set(-2, 7, 0);

    head.add(horn2);
    head.add(horn1);
    head.add(band1);
    head.add(mouth);
    head.add(eyeBrow1);
    head.add(eyeBrow2);
    head.add(circle);
    head.add(beginHair);
    head.add(hair);
    return head;
}

function createBody() {
    var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
    var body = new THREE.Group();

    // torse
    var geometry = new THREE.BoxGeometry( 8, 4, 4);
    var material = new THREE.MeshBasicMaterial( {color: 0xff0000} );
    var torse = new THREE.Mesh( geometry, material );
    torse.rotation.z = Math.PI/2;
    torse.scale.set(2,2,2);
    body.add(torse);

    // dress
    var points = [];
    for (var i = 0; i < 10; i++) {
    points.push(new THREE.Vector2(Math.cos(i * 0.2) * 3 + 3, (i - 5) * 0.8));
    }
    var latheGeometry = new THREE.LatheGeometry(points);
    var dress = new THREE.Mesh( latheGeometry, material );
    dress.scale.set(1.5, 3.5, 1.5);
    dress.position.y = -10;
    body.add(dress);

    // 1st forearm
    var forearmGeometry = new THREE.CylinderGeometry( 2, 2, 20, 50 );
    var forearm1 = new THREE.Mesh( forearmGeometry, material );
    forearm1.scale.set(1, 0.7, 1);
    forearm1.position.set(16, 13, 0);
    forearm1.rotation.z = -0.6;
    body.add(forearm1);

    // 2nd forearm
    var forearm2 = new THREE.Mesh( forearmGeometry, material );
    forearm2.scale.set(1, 0.7, 1);
    forearm2.position.set(-16, 13, 0);
    forearm2.rotation.z = 0.6;
    body.add(forearm2);

    // 1st arm
    var arm1 = new THREE.Mesh( forearmGeometry, material );
    arm1.scale.set(1, 0.3, 1);
    arm1.rotation.z = Math.PI/2;
    arm1.position.set(7, 6, 0);
    body.add(arm1);

    // 2nd arm
    var arm2 = new THREE.Mesh( forearmGeometry, material );
    arm2.scale.set(1, 0.3, 1);
    arm2.rotation.z = Math.PI/2;
    arm2.position.set(-7, 6, 0);
    console.log(arm2);
    body.add(arm2);

    // 1st sphere arm
    var sphereGeometry = new THREE.SphereGeometry( 2, 32, 32 );
    var sphereMaterial = new THREE.MeshBasicMaterial( {color: 0x808080} );
    var sphere1 = new THREE.Mesh( sphereGeometry, sphereMaterial );
    sphere1.position.set(11, 6, 0);
    body.add(sphere1);

    // 2nd sphere arm
    var sphere2 = new THREE.Mesh( sphereGeometry, sphereMaterial );
    sphere2.position.set(-11, 6, 0);
    body.add(sphere2);

    // 1st leg
    var legGeometry = new THREE.CylinderGeometry( 1, 2, 30, 32 );
    var legMaterial = new THREE.MeshBasicMaterial( {color: 0x000000} );
    var leg1 = new THREE.Mesh( legGeometry, legMaterial );
    leg1.position.set(-4, -30, 0);
    body.add(leg1);

    // 2nd leg
    var leg2 = new THREE.Mesh( legGeometry, legMaterial );
    leg2.position.set(4, -30, 0);
    body.add(leg2);

    // 1st boot
    var whiteMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
    var bootPoints = [];
    for ( var i = 0; i < 5; i ++ ) {
	    bootPoints.push(new THREE.Vector2( 2, i));
    }
    var bootGeometry = new THREE.LatheGeometry(bootPoints);
    var boot1 = new THREE.Mesh(bootGeometry, whiteMaterial);
    boot1.position.set(4, -45, 0);
    body.add(boot1);

    // 2nd boot
    var boot2 = new THREE.Mesh(bootGeometry, whiteMaterial);
    boot2.position.set(-4, -45, 0);
    body.add(boot2);

    // 1st foot
    var shape = new THREE.Shape();
    shape.moveTo(-1, 0);
    //shape.lineTo(3, 0);
    shape.bezierCurveTo(-0.5, 0.25, 0.5, 0.25, 1, 0);
    shape.lineTo(-1, 0);
    console.log(shape);
    //

    var extrudeSettings = {
        steps: 20,
        depth: 3,
        bevelEnabled: true,
        bevelThickness: 1,
        bevelSize: 1,
        bevelOffset: 0,
        bevelSegments: 1
    }

    var footGeometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
    var wireframeMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
    var foot1 = new THREE.Mesh(footGeometry, wireframeMaterial);
    foot1.scale.set(1, 2, 1.8);
    foot1.position.set(4, -47, -1);
    body.add(foot1);

    // 2nd foot
    var foot2 = new THREE.Mesh(footGeometry, wireframeMaterial);
    foot2.scale.set(1, 2, 1.8);
    foot2.position.set(-4, -47, -1);
    body.add(foot2);

    // HANDS

    // 1st wrist
    var skinMaterial = new THREE.MeshBasicMaterial({color: 0xf7e7ce});
    var wrist1 = new THREE.Mesh( forearmGeometry, skinMaterial );
    wrist1.scale.set(0.7, 0.2, 0.7);
    wrist1.position.set(21, 20, 0);
    wrist1.rotation.z = -0.6;
    body.add(wrist1);

    // 1st palm
    var palmRadius = 1.5;  
    var palmTubeRadius = 1.5;  
    var palmRadialSegments = 8;  
    var palmTubularSegments = 24;  
    var palmGeometry = new THREE.TorusGeometry(palmRadius, palmTubeRadius, palmRadialSegments, palmTubularSegments);
    var palm1 = new THREE.Mesh(palmGeometry, skinMaterial);
    palm1.position.set(23, 22, 0);
    palm1.rotation.x = Math.PI/2;
    body.add(palm1);

    // 2nd wrist
    var wrist2 = new THREE.Mesh( forearmGeometry, skinMaterial );
    wrist2.scale.set(0.7, 0.2, 0.7);
    wrist2.position.set(-21, 20, 0);
    wrist2.rotation.z = 0.6;
    body.add(wrist2);

    // 2nd palm
    var palm2 = new THREE.Mesh(palmGeometry, skinMaterial);
    palm2.position.set(-23, 22, 0);
    palm2.rotation.x = Math.PI/2;
    body.add(palm2);

    // Flashlight
    var flashlight1 = createLathe(0xffcc00);
    flashlight1.scale.set(0.4, 0.4, 0.4);
    flashlight1.position.set(23, 26, 0);
    body.add(flashlight1);

    // Holder
    var holderRadiusTop =  1.3;  
    var holderRadiusBottom =  0.7;  
    var holderHeight = 12;  
    var holderRadialSegments = 12;  
    var holderGeometry = new THREE.CylinderGeometry(holderRadiusTop, holderRadiusBottom, holderHeight, holderRadialSegments);
    var holderMaterial = new THREE.MeshBasicMaterial({color: 0x312113});
    var holder1 = new THREE.Mesh(holderGeometry, holderMaterial);
    holder1.position.set(23, 20, 0);
    body.add(holder1);

    // Neck
    var neck1 = new THREE.Mesh( forearmGeometry, skinMaterial );
    neck1.position.set(0, 5, 0);
    body.add(neck1);

    // Arrows (dress)
    var arrowShape = new THREE.Shape();
    arrowShape.moveTo(1, 0);
    arrowShape.lineTo(2, 0);
    arrowShape.lineTo(1.5, 1.5);
    arrowShape.lineTo(2, 3);
    arrowShape.lineTo(1, 3);
    arrowShape.lineTo(0.5, 1.5);
    arrowShape.lineTo(1, 0);

    var ArrowExtrudeSettings = {
        steps: 2,
        depth: 0.5,
        bevelEnabled: false,
        bevelThickness: 1,
        bevelSize: 1,
        bevelOffset: 0,
        bevelSegments: 1
    };

    var arrowGeometry = new THREE.ExtrudeGeometry( arrowShape, ArrowExtrudeSettings);
    var arrowMaterial = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
    var arrow1 = new THREE.Mesh( arrowGeometry, arrowMaterial );
    arrow1.scale.set(1, 0.5, 1);
    arrow1.position.set(1, -1, 3.7);

    var arrowEdges = new THREE.EdgesGeometry(arrowGeometry);
    var arrowLine1 = new THREE.LineSegments( arrowEdges, new THREE.LineBasicMaterial( { color: 0x000000 } ) );
    arrowLine1.scale.set(1, 0.5, 1);
    arrowLine1.position.set(1, -1, 3.7);

    body.add(arrow1);
    body.add(arrowLine1);

    var arrow2 = new THREE.Mesh( arrowGeometry, arrowMaterial );
    arrow2.scale.set(1, 0.5, 1);
    arrow2.position.set(-1, -1, 4.2);
    arrow2.rotation.y = Math.PI;
    var arrowLine2 = new THREE.LineSegments( arrowEdges, new THREE.LineBasicMaterial( { color: 0x000000 } ) );
    arrowLine2.scale.set(1, 0.5, 1);
    arrowLine2.position.set(-1, -1, 4.2);
    arrowLine2.rotation.y = Math.PI;

    body.add(arrow2);
    body.add(arrowLine2);

    var arrowMaterial2 = new THREE.MeshBasicMaterial({color: 0xb8860b});
    var arrow3 = new THREE.Mesh( arrowGeometry, arrowMaterial2 );
    arrow3.scale.set(0.8, 0.4, 1);
    arrow3.position.set(0, -1, 3.7);
    var arrowLine3 = new THREE.LineSegments( arrowEdges, new THREE.LineBasicMaterial( { color: 0x000000 } ) );
    arrowLine3.scale.set(0.8, 0.4, 1);
    arrowLine3.position.set(0, -1, 3.7);

    var arrow4 = new THREE.Mesh( arrowGeometry, arrowMaterial2 );
    arrow4.scale.set(0.8, 0.4, 1);
    arrow4.rotation.y = Math.PI;
    arrow4.position.set(0, -1, 4.2);
    var arrowLine4 = new THREE.LineSegments( arrowEdges, new THREE.LineBasicMaterial( { color: 0x000000 } ) );
    arrowLine4.scale.set(0.8, 0.4, 1);
    arrowLine4.rotation.y = Math.PI;
    arrowLine4.position.set(0, -1, 4.2);

    body.add(arrow3);
    body.add(arrow4);
    body.add(arrowLine3);
    body.add(arrowLine4);

    // belt

    var beltPoints = [];
    for (let i = 4; i < 6; ++i) {
        beltPoints.push(new THREE.Vector2(7, i));
    }
    var beltGeometry = new THREE.LatheGeometry(beltPoints);
    var beltMaterial = new THREE.MeshBasicMaterial({color: 0x654321});
    var belt1 = new THREE.Mesh(beltGeometry, beltMaterial);
    belt1.scale.set(0.85, 0.85, 0.6);
    belt1.position.set(0, -4.3, -0.7);
    body.add(belt1);

    // collar
    var collarGeometry = new THREE.BoxGeometry(5, 5, 5);
    var collarMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
    var collar1 = new THREE.Mesh(collarGeometry, collarMaterial);
    body.add(collar1);
    collar1.position.set(0, 10, 0);

    // tie
    var tieShape = new THREE.Shape();
    tieShape.moveTo(2, 2);
    tieShape.lineTo(3, 1);
    tieShape.lineTo(4, 2);
    tieShape.lineTo(3, 5);
    tieShape.lineTo(3.5, 5.5);
    tieShape.lineTo(3, 6);
    tieShape.lineTo(2.5, 5.5);
    tieShape.lineTo(3, 5);
    tieShape.lineTo(2, 2);
    

    var tieSettings = {
        steps: 2,
        depth: 0.5,
        bevelEnabled: false,
        bevelThickness: 1,
        bevelSize: 1,
        bevelOffset: 0,
        bevelSegments: 1
    };

    var tieGeometry = new THREE.ExtrudeGeometry(tieShape, tieSettings);
    var tieMaterial = new THREE.MeshBasicMaterial({color: 0xffa500});
    var tie1 = new THREE.Mesh(tieGeometry, tieMaterial);
    tie1.scale.set(0.9, 0.9, 0.9);
    tie1.position.set(-2.75, 7.1, 2.5);

    body.add(tie1);

    // COMPLETE LEAF
    
    var completeLeaf1 = createComplexLeaf(0x006400, 0x149414);
    completeLeaf1.position.set(0, 0, 0);
    completeLeaf1.scale.set(0.7, 0.7, 0.7);
    completeLeaf1.rotateOnWorldAxis(new THREE.Vector3(0,0,1), -0.9);
    completeLeaf1.position.set(9, 12.5, 0);
    // completeLeaf1.rotation.z = -0.3;
    
    var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
    var completeLeaf2 = createComplexLeaf(randomColor, randomColor);
    completeLeaf2.translateZ(-100).translateY(-10);
    completeLeaf2.rotation.z = -0.6;
    completeLeaf2.rotation.y = Math.PI/2;

    body.add(completeLeaf2);
    body.add(completeLeaf1);

    return body;
}

function createComplexLeaf(color1, color2) {

    var completeLeaf1 = new THREE.Group();

    // stem

    var stemGeometry = new THREE.CylinderGeometry(0.2, 0.2, 10, 50);
    var stemMaterial = new THREE.MeshBasicMaterial( {color: color1} );
    var stem1 = new THREE.Mesh(stemGeometry, stemMaterial);

    stem1.position.y = 30;
    completeLeaf1.add(stem1);

    // leaves
    var leafShape = new THREE.Shape();
    leafShape.moveTo(0, 0);
    leafShape.bezierCurveTo(1, 2, 1, 3, 0, 4);
    leafShape.bezierCurveTo(-1, 3, -1, 2, 0, 0);

    var leafSettings = {
        steps: 2,
        depth: 0.5,
        bevelEnabled: false,
        bevelThickness: 1,
        bevelSize: 1,
        bevelOffset: 0,
        bevelSegments: 1
    };

    var leafGeometry = new THREE.ExtrudeGeometry(leafShape, leafSettings);
    var leafMaterial = new THREE.MeshBasicMaterial({color: color2});
    var leaf1 = new THREE.Mesh(leafGeometry, leafMaterial);
    leaf1.scale.set(1, 2, 1);
    leaf1.position.y = 34;

    // right side

    var leaf2 = new THREE.Mesh(leafGeometry, leafMaterial);
    leaf2.scale.set(1, 1.5, 1);
    leaf2.position.set(0, 34, 0);
    leaf2.rotation.z = -0.6;

    var leaf3 = new THREE.Mesh(leafGeometry, leafMaterial);
    leaf3.scale.set(1, 1.5, 1);
    leaf3.position.set(0, 32, 0);
    leaf3.rotation.z = -0.8;

    var leaf4 = new THREE.Mesh(leafGeometry, leafMaterial);
    leaf4.scale.set(1, 1.5, 1);
    leaf4.position.set(0, 29.5, 0);
    leaf4.rotation.z = -0.8;

    // left side

    var leaf5 = new THREE.Mesh(leafGeometry, leafMaterial);
    leaf5.scale.set(1, 1.5, 1);
    leaf5.position.set(0, 34, 0);
    leaf5.rotation.y = Math.PI;
    leaf5.rotation.z = -0.6;

    var leaf6 = new THREE.Mesh(leafGeometry, leafMaterial);
    leaf6.scale.set(1, 1.5, 1);
    leaf6.position.set(0, 32, 0);
    leaf6.rotation.y = Math.PI;
    leaf6.rotation.z = -0.8;

    var leaf7 = new THREE.Mesh(leafGeometry, leafMaterial);
    leaf7.scale.set(1, 1.5, 1);
    leaf7.position.set(0, 29.5, 0);
    leaf7.rotation.y = Math.PI;
    leaf7.rotation.z = -0.8;

    completeLeaf1.add(leaf7);
    completeLeaf1.add(leaf6);
    completeLeaf1.add(leaf5);
    completeLeaf1.add(leaf4);
    completeLeaf1.add(leaf3);
    completeLeaf1.add(leaf2);
    completeLeaf1.add(leaf1);

    console.log("leaf pos " + completeLeaf1.position.x);

    // BEAUTIFUL EFFECT TBH completeLeaf1.translateX(-80);
    completeLeaf1.rotation.y = Math.PI/2;
    return completeLeaf1;
}

function createZeroTwo() {
    var zerotwo1 = new THREE.Group();
    var head1 = createHead();
    head1.position.x = 0;

    var body1 = createBody();
    body1.position.x = 0;
    body1.position.y = -20;
    
    zerotwo1.add(head1);
    zerotwo1.add(body1);
    return zerotwo1;
}

function createLathe(color) {
    const points = [];
    for (var i = 0; i < 5; i+=0.5) {
        points.push(new THREE.Vector3(i + 4, 0.5*i*i, 0));
    }

    for (var i = 11.125; i < 16; i++ ) {
        points.push(new THREE.Vector3(8.5, i + 0.1*i, 0));
    }

    
    points.push(new THREE.Vector3(8, 18.25, 0));
    points.push(new THREE.Vector3(7.5, 20.125, 0));
    points.push(new THREE.Vector3(7, 21.75, 0));
    points.push(new THREE.Vector3(6.5, 23.125, 0));
    points.push(new THREE.Vector3(6, 24.25, 0));
    points.push(new THREE.Vector3(5.5, 25.125, 0));
    points.push(new THREE.Vector3(5, 25.75, 0));
    points.push(new THREE.Vector3(4.5, 26.125, 0));
    points.push(new THREE.Vector3(4, 26.25, 0));

    
    //console.log(points);

    const segments = 50;  
    const phiStart = Math.PI * 2.00;  
    const phiLength = Math.PI * 2.00;  
    const geometry = new THREE.LatheGeometry(points, segments, phiStart, phiLength);
    var material = new THREE.MeshBasicMaterial( { color: color, wireframe: true} );
    const lathe = new THREE.Mesh( geometry, material );
    return lathe;

}

function createEdges(geometry) {
    const edges = new THREE.EdgesGeometry( geometry );
    const line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0x000000 } ) );
    return line;
}

function createPiece(color) {
    const shape = new THREE.Shape();
    const x = -0.5;
    const y = 0;
    shape.moveTo(-0.5, 0);
    shape.lineTo(0, 1);
    shape.lineTo(0.5, 0);
    shape.bezierCurveTo(0.2, -0.1, -0.2, -0.1, -0.5, 0);
    
    const extrudeSettings = {
        steps: 2,  
        depth: 0.05,  
        bevelEnabled: true,  
        bevelThickness: 0.1,  
        bevelSize: 0.1,  
        bevelSegments: 0,  
    };

    var geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    var material = new THREE.MeshBasicMaterial( {color: color} );
    var mesh = new THREE.Mesh( geometry, material);
    return mesh;
}

function loadFont(url) {
    const loader = new THREE.FontLoader();
    return new Promise((resolve, reject) => {
    loader.load(url, resolve, undefined, reject);
    });
}

async function doit() {
    const font = await loadFont('https://threejsfundamentals.org/threejs/resources/threejs/fonts/helvetiker_regular.typeface.json');  
    const geometry = new THREE.TextGeometry('three.js', {
    font: font,
    size: 3.0,
    height: .2,
    curveSegments: 12,
    bevelEnabled: true,
    bevelThickness: 0.15,
    bevelSize: .3,
    bevelSegments: 5,
    });
    const mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({color: 0x00ff00}));
    geometry.computeBoundingBox();
    geometry.boundingBox.getCenter(mesh.position).multiplyScalar(-1);
    sceneElements.sceneGraph.add(mesh);
}

function createText() {
    
var loader = new THREE.FontLoader();

loader.load( 'fonts/helvetiker_regular.typeface.js', function ( font ) {

var material = new THREE.MeshPhongMaterial( { color: 0x0033ff, specular: 0x555555, shininess: 30 } );

var geometry = new THREE.TextGeometry( 'Hello three.js!', {
    font: font,
    size: 20000000000,
    height: 5,
    curveSegments: 12,
    bevelEnabled: true,
    bevelThickness: 10,
    bevelSize: 8,
    bevelSegments: 5
} );

var mesh = new THREE.Mesh( geometry, material );

sceneElements.sceneGraph.add(mesh);

var light = new THREE.DirectionalLight( 0xffffff );
light.position.set( 0, 1, 1 ).normalize();
sceneElements.sceneGraph.add(light);


var renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );

renderer.render(  sceneElements.sceneGraph, sceneElements.camera );

} );
console.log(loader);
}
        function generatePoints() {    
        var points = [];
        for (var i = 0; i < 25; i++) {
        var randomX = Math.round(Math.random() * 4);
        var randomY = Math.round(Math.random() * 25);
        var randomZ = Math.round(Math.random() * 4);
        
        points.push(new THREE.Vector3(randomX, randomY, randomZ));
        //console.log(new THREE.Vector3(randomX, randomY, randomZ));
    }
    return points;
}

function goodPointsArray(array) {
    var count = 0;
    for (var i = 0; i < array.length; i++) {
    var point = array[i];
    if (point.y == 0) {
        count = count + 1;
    }
    }
    if (count >= 3) {
    return true;
    } else {
    return false;
    }
}

function makeStone() {

    var points = generatePoints();

    var bool = goodPointsArray(points);
    while (!bool) {
    points = generatePoints();
    bool = goodPointsArray(points);
    }

    var material2 = new THREE.MeshLambertMaterial({
                color: "rgb(128,128,128)",
                transparent: true
            });
    const meshGeometry = new ConvexGeometry(points);

    const stone = new THREE.Mesh(meshGeometry, material2);
    return stone;
}

function createMaze() {
    var maze = new THREE.Group();
    var planeGeometry = new THREE.PlaneGeometry( 100, 100, 32 );
    var planeMaterial = new THREE.MeshBasicMaterial( {color: 0x0000ff, side: THREE.DoubleSide} );
    var plane1 = new THREE.Mesh(planeGeometry, planeMaterial);
    plane1.position.set(0, 0, 100);
    plane1.rotation.x = Math.PI/2;

    var wall1 = new THREE.Mesh(planeGeometry, planeMaterial);
    wall1.position.set(50, 15, 100);
    wall1.scale.set(1, 0.3, 1);
    wall1.rotation.y = Math.PI/2;

    var boxGeometry = new THREE.BoxGeometry( 10, 10, 10);
    
    
    var usedXValues = [];
    var usedZValues = [];

    var xPossibleValues1stRow = [-45, -35, -25, -15, 15, 25, 35, 45];

    // 1st row of the maze
    var count = 0;
    while (count < 8) {
        var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
        var boxMaterial = new THREE.MeshBasicMaterial( {color: randomColor} );

        console.log(xPossibleValues1stRow);
        var itemX = xPossibleValues1stRow[Math.floor(Math.random() * xPossibleValues1stRow.length)];
        var box = new THREE.Mesh(boxGeometry, boxMaterial);
        box.position.set(itemX, 5, 55);
        for( var i = 0; i < xPossibleValues1stRow.length; i++){ 
            if ( xPossibleValues1stRow[i] === itemX) { 
                xPossibleValues1stRow.splice(i, 1); 
                i--; 
            }
        }
        maze.add(box);
        count = count + 1;
    }

    var xPossibleValues2ndRow = [-45, -35, -25, -15, 15, 25, 35, 45];
    var possibleNumberBoxes = [4, 5, 6, 7, 8];
    var numberBoxes = possibleNumberBoxes[Math.floor(Math.random() * possibleNumberBoxes.length)];
    // 2nd row
    for (var k=0; k < numberBoxes; k++) {
        var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
        var boxMaterial = new THREE.MeshBasicMaterial( {color: randomColor} );
        var itemX = xPossibleValues2ndRow[Math.floor(Math.random() * xPossibleValues2ndRow.length)];
        var box = new THREE.Mesh(boxGeometry, boxMaterial);
        box.position.set(itemX, 5, 65);
        for( var i = 0; i < xPossibleValues2ndRow.length; i++){ 
            if ( xPossibleValues2ndRow[i] === itemX) { 
                xPossibleValues2ndRow.splice(i, 1); 
                i--; 
            }
        }
        maze.add(box);
    }

    var xPossibleValues3rdRow = [-45, -35, -25, 25, 35, 45];
    // 3rd row
    var possibleNumberBoxes = [4, 5, 6, 7, 8];
    var numberBoxes = possibleNumberBoxes[Math.floor(Math.random() * possibleNumberBoxes.length)];
    for (var k=0; k < numberBoxes; k++) {
        var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
        var boxMaterial = new THREE.MeshBasicMaterial( {color: randomColor} );
        var itemX = xPossibleValues3rdRow[Math.floor(Math.random() * xPossibleValues3rdRow.length)];
        var box = new THREE.Mesh(boxGeometry, boxMaterial);
        box.position.set(itemX, 5, 75);
        for( var i = 0; i < xPossibleValues3rdRow.length; i++){ 
            if ( xPossibleValues3rdRow[i] === itemX) { 
                xPossibleValues3rdRow.splice(i, 1); 
                i--; 
            }
        }
        maze.add(box);
    }

    var xPossibleValues4thRow = [-45, -35, -25, -5, 5, 25, 35, 45];
    // 4th row
    var possibleNumberBoxes = [4, 5, 6, 7, 8];
    var numberBoxes = possibleNumberBoxes[Math.floor(Math.random() * possibleNumberBoxes.length)];
    for (var k=0; k < numberBoxes; k++) {
        var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
        var boxMaterial = new THREE.MeshBasicMaterial( {color: randomColor} );
        var itemX = xPossibleValues4thRow[Math.floor(Math.random() * xPossibleValues4thRow.length)];
        var box = new THREE.Mesh(boxGeometry, boxMaterial);
        box.position.set(itemX, 5, 85);
        for( var i = 0; i < xPossibleValues4thRow.length; i++){ 
            if ( xPossibleValues4thRow[i] === itemX) { 
                xPossibleValues4thRow.splice(i, 1); 
                i--; 
            }
        }
        maze.add(box);
    }

    var xPossibleValues5thRow = [-45, -5, 5, 45];
    // 5th row
    var possibleNumberBoxes = [4, 5, 6, 7, 8];
    var numberBoxes = possibleNumberBoxes[Math.floor(Math.random() * possibleNumberBoxes.length)];
    for (var k=0; k < numberBoxes; k++) {
        var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
        var boxMaterial = new THREE.MeshBasicMaterial( {color: randomColor} );
        var itemX = xPossibleValues5thRow[Math.floor(Math.random() * xPossibleValues5thRow.length)];
        var box = new THREE.Mesh(boxGeometry, boxMaterial);
        box.position.set(itemX, 5, 95);
        for( var i = 0; i < xPossibleValues5thRow.length; i++){ 
            if ( xPossibleValues5thRow[i] === itemX) { 
                xPossibleValues5thRow.splice(i, 1); 
                i--; 
            }
        }
        maze.add(box);
    }

    var xPossibleValues6thRow = [-45, -25, -15, -5, 5, 15, 25, 45];
    // 6th row
    var possibleNumberBoxes = [4, 5, 6, 7, 8];
    var numberBoxes = possibleNumberBoxes[Math.floor(Math.random() * possibleNumberBoxes.length)];
    for (var k=0; k < numberBoxes; k++) {
        var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
        var boxMaterial = new THREE.MeshBasicMaterial( {color: randomColor} );
        var itemX = xPossibleValues6thRow[Math.floor(Math.random() * xPossibleValues6thRow.length)];
        var box = new THREE.Mesh(boxGeometry, boxMaterial);
        box.position.set(itemX, 5, 105);
        for( var i = 0; i < xPossibleValues6thRow.length; i++){ 
            if ( xPossibleValues6thRow[i] === itemX) { 
                xPossibleValues6thRow.splice(i, 1); 
                i--; 
            }
        }
        maze.add(box);
    }

    var xPossibleValues7thRow = [-45, -5, 5, 45];
    // 7th row
    var possibleNumberBoxes = [4, 5, 6, 7, 8];
    var numberBoxes = possibleNumberBoxes[Math.floor(Math.random() * possibleNumberBoxes.length)];
    for (var k=0; k < numberBoxes; k++) {
        var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
        var boxMaterial = new THREE.MeshBasicMaterial( {color: randomColor} );
        var itemX = xPossibleValues7thRow[Math.floor(Math.random() * xPossibleValues7thRow.length)];
        var box = new THREE.Mesh(boxGeometry, boxMaterial);
        box.position.set(itemX, 5, 115);
        for( var i = 0; i < xPossibleValues7thRow.length; i++){ 
            if ( xPossibleValues7thRow[i] === itemX) { 
                xPossibleValues7thRow.splice(i, 1); 
                i--; 
            }
        }
        maze.add(box);
    }

    var xPossibleValues8thRow = [-45, -35, -25, -5, 5, 25, 35, 45];
    // 8th row
    var possibleNumberBoxes = [4, 5, 6, 7, 8];
    var numberBoxes = possibleNumberBoxes[Math.floor(Math.random() * possibleNumberBoxes.length)];
    for (var k=0; k < numberBoxes; k++) {
        var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
        var boxMaterial = new THREE.MeshBasicMaterial( {color: randomColor} );
        var itemX = xPossibleValues8thRow[Math.floor(Math.random() * xPossibleValues8thRow.length)];
        var box = new THREE.Mesh(boxGeometry, boxMaterial);
        box.position.set(itemX, 5, 125);
        for( var i = 0; i < xPossibleValues8thRow.length; i++){ 
            if ( xPossibleValues8thRow[i] === itemX) { 
                xPossibleValues8thRow.splice(i, 1); 
                i--; 
            }
        }
        maze.add(box);
    }

    var xPossibleValues9thRow = [-45, -35, -25, 25, 35, 45];
    // 9th row
    var possibleNumberBoxes = [4, 5, 6, 7, 8];
    var numberBoxes = possibleNumberBoxes[Math.floor(Math.random() * possibleNumberBoxes.length)];
    for (var k=0; k < numberBoxes; k++) {
        var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
        var boxMaterial = new THREE.MeshBasicMaterial( {color: randomColor} );
        var itemX = xPossibleValues9thRow[Math.floor(Math.random() * xPossibleValues9thRow.length)];
        var box = new THREE.Mesh(boxGeometry, boxMaterial);
        box.position.set(itemX, 5, 135);
        for( var i = 0; i < xPossibleValues9thRow.length; i++){ 
            if ( xPossibleValues9thRow[i] === itemX) { 
                xPossibleValues9thRow.splice(i, 1); 
                i--; 
            }
        }
        maze.add(box);
    }

    var xPossibleValues10thRow = [-45, -35, -25, -15, 15, 25, 35, 45];
    // 10th row
    var count = 0;
    while (count < 8) {
        var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
        var boxMaterial = new THREE.MeshBasicMaterial( {color: randomColor} );
        var itemX = xPossibleValues10thRow[Math.floor(Math.random() * xPossibleValues10thRow.length)];
        var box = new THREE.Mesh(boxGeometry, boxMaterial);
        box.position.set(itemX, 5, 145);
        for( var i = 0; i < xPossibleValues10thRow.length; i++){ 
            if ( xPossibleValues10thRow[i] === itemX) { 
                xPossibleValues10thRow.splice(i, 1); 
                i--; 
            }
        }
        maze.add(box);
        count = count + 1;
    }





    

    


        
    /*
    for (var i=0; i<15; i++) {
        var box = new THREE.Mesh(boxGeometry, boxMaterial);
        var xValue = Math.pow(-1, i) * Math.floor(Math.random() * 49.5);
        while (usedXValues.includes(xValue)) {
            xValue = Math.pow(-1, i) * Math.floor(Math.random() * 49.5);
        }
        usedXValues.push(xValue);
        var zValue = Math.floor(Math.random() * 100) + 49.5;
        while (usedZValues.includes(zValue)) {
            zValue = Math.floor(Math.random() * 100) + 49.5;
        }
        usedZValues.push(zValue);

        box.position.set(xValue, 5, zValue);
        maze.add(box);
    }
    */

    maze.add(wall1);
    maze.add(plane1);

    return maze;
}
        
    var existingZeroTwoObjects = [];
    var removedZeroTwoObjects = [];

        // Create and insert in the scene graph the models of the 3D scene
    function load3DObjects(sceneGraph) {

            // ************************** //
            // Create a ground plane
            // ************************** //
        const pgeometry = new THREE.PlaneGeometry( 100, 100, 32 );
        const pmaterial = new THREE.MeshBasicMaterial( {color: 0x567d46, side: THREE.DoubleSide} );
        const plane = new THREE.Mesh( pgeometry, pmaterial );
        plane.rotation.x = Math.PI / 2;
        sceneGraph.add( plane );

        var axes = new THREE.AxisHelper(500);  
        sceneGraph.add(axes);

        var stone1 = makeStone();
        var center1 = new THREE.Object3D();
        center1.name = "center1";
        center1.add(stone1);
        sceneGraph.add(center1);
        stone1.position.x = 30;

        var stone2 = makeStone();
        var center2 = new THREE.Object3D();
        center2.name = "center2";
        center2.add(stone2);
        sceneGraph.add(center2);
        stone2.position.x = -30;

        var stone3 = makeStone();
        var center3 = new THREE.Object3D();
        center3.name = "center3";
        center3.add(stone3);
        sceneGraph.add(center3);
        stone3.position.z = 30;

        var stone4 = makeStone();
        var center4 = new THREE.Object3D();
        center4.name = "center4";
        center4.add(stone4);
        sceneGraph.add(center4);
        stone4.position.z = -30;

        // Rotated stones (midpoints)
        for (var i = 5; i < 9; i++) {
            var stone = makeStone();
            stone.name = "stone" + i;
            var center = new THREE.Object3D();
            center.name = "center" + i;
            center.add(stone);
            sceneGraph.add(center);
            stone.position.x = 30;
            center.rotation.y = Math.PI/4 + i*(Math.PI/2);
        }
    



        var center = new THREE.Object3D();
    center.name = "center";

    for (var i=0; i<100; i++) {
        var piece = createPiece(0x00472a);
        center.add(piece);
        piece.position.y = 1;
        piece.position.x = Math.cos(1 + i*0.1);
        piece.position.z = Math.sin(1 + i*0.1);
        //console.log(piece);
    }
    var randomNumber = Math.random();
    for (var i=0; i<100; i++) {
        var piece = createPiece(0x00472a);
        //piece.scale.set(0.5,0.5,0.5);
        center.add(piece);
        piece.position.y = 2;
        piece.position.x = Math.cos(1 + i*0.1)/1.1;
        //piece.rotation.y = Math.PI * randomNumber;
        piece.position.z = Math.sin(1 + i*0.1)/1.1;
    }

    var randomNumber = Math.random();
    for (var i=0; i<100; i++) {
        var piece = createPiece(0x00472a);
        //piece.scale.set(0.5,0.5,0.5);
        center.add(piece);
        piece.position.y = 3;
        piece.position.x = Math.cos(1 + i*0.1)/1.2;
        //piece.rotation.y = Math.PI * randomNumber;
        piece.position.z = Math.sin(1 + i*0.1)/1.2;
    }
    var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
    var randomNumber = Math.random();
    for (var i=0; i<100; i++) {
        var piece = createPiece(0x00472a);
        //piece.scale.set(0.5,0.5,0.5);
        center.add(piece);
        piece.position.y = 4;
        piece.position.x = Math.cos(1 + i*0.1)/1.3;
        //piece.rotation.y = Math.PI * randomNumber;
        piece.position.z = Math.sin(1 + i*0.1)/1.3;
    }
    var randomNumber = Math.random();
    for (var i=0; i<400; i++) {
        var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
        var piece = createPiece(randomColor);
        piece.scale.set(1.3, 1.3, 1.3);
        center.add(piece);
        piece.position.y = 5.2;
        //piece.position.x = Math.cos(i)/3;
        piece.rotation.y = THREE.Math.degToRad(i);
        //piece.position.z = Math.sin(i)/3;
    }

    center.position.set(-45, 0, -45);
    center.scale.set(2, 2 , 2);

    var lathe1 = createLathe(0x000000);
    sceneGraph.add(lathe1);
    lathe1.position.x = -2;
    lathe1.position.y = 10;
    lathe1.name = "lathe1";

    // Make zero two character

    var zerotwoOriginal = createZeroTwo();
    sceneGraph.add(zerotwoOriginal);
    zerotwoOriginal.position.set(100, 0, 0);
    zerotwoOriginal.name = "zerotwoOriginal";
    /*
    var zerotwo2 = createZeroTwo();
    sceneGraph.add(zerotwo2);
    zerotwo2.scale.set(0.2, 0.2, 0.2);
    zerotwo2.position.set(20, 13.5, 0);
    zerotwo2.name = "zerotwo2";
    */

    // Create and rotate zero twos
    for (var i = 1; i < 9; i++) {
        var zerotwo = createZeroTwo();
        var rotateZeroTwo = new THREE.Object3D();
        rotateZeroTwo.add(zerotwo);
        zerotwo.scale.set(0.2, 0.2, 0.2);
        zerotwo.position.set(20, 13.5, 0);
        zerotwo.name = "zerotwo" + i;
        rotateZeroTwo.name = "rotateZeroTwo" + i;
        rotateZeroTwo.rotation.y = i*(Math.PI/4);
        sceneGraph.add(rotateZeroTwo);

        existingZeroTwoObjects.push(rotateZeroTwo);
    }
    //var centerZeroTwo2 = new THREE.Object3D();
    //centerZeroTwo2.position.set(0, 0, 5);
    //centerZeroTwo2.add(zerotwo2);

    //sceneGraph.add(centerZeroTwo2);
    //centerZeroTwo2.name = "centerzerotwo2";




    /*
        NICE IDEA TO MAKE A NEW KIND OF TREE!! :)
    for (var i=0; i<100; i++) {
        var piece = createPiece(0x000000);
        //piece.scale.set(0.5,0.5,0.5);
        center.add(piece);
        piece.position.y = 4;
        piece.position.x = Math.cos(1 + i*0.1)/1.3;
        piece.rotation.y = Math.PI * Math.random() * 10;
        piece.position.z = Math.sin(1 + i*0.1)/1.3;
    }
    */


    sceneGraph.add(center);
    
    console.log(existingZeroTwoObjects);

    // Create Mazes
    var maze1 = createMaze();
    sceneGraph.add(maze1);
}
    

        // ANIMATING
        // Displacement value

        var delta = 0.1;

        var dispX = 0.2, dispZ = 0.2;

        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2(0.01, 0.01);

        //var quaternion = new THREE.Quaternion().setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI / 2 );
        var countSpeed = 0;
        var countReduceSpeed = 0.01;
        function computeFrame(time) {

            var lathe1 = sceneElements.sceneGraph.getObjectByName("lathe1");
            lathe1.rotation.y += 0.05;


            // dynamically remove zero twos
            if (keyMinus && existingZeroTwoObjects.length > 0) {
                var randomItem = existingZeroTwoObjects[existingZeroTwoObjects.length - 1];
                removedZeroTwoObjects.push(randomItem);
                sceneElements.sceneGraph.remove(randomItem);
                existingZeroTwoObjects.pop(randomItem);
                console.log(existingZeroTwoObjects);
            }

            if (keyPlus && existingZeroTwoObjects.length <=8 && removedZeroTwoObjects.length != 0) {
                var object = removedZeroTwoObjects[removedZeroTwoObjects.length - 1];
                console.log(removedZeroTwoObjects[0]);
                console.log("keyplus: " + object);
                sceneElements.sceneGraph.add(object);
                removedZeroTwoObjects.pop(object);
                existingZeroTwoObjects.push(object);
            }
            
             // rotate zero twos
             for (var i=0; i<existingZeroTwoObjects.length; i++) {
                var zerotwoObject = sceneElements.sceneGraph.getObjectByName(existingZeroTwoObjects[i].name);
                console.log("Zero Two Object:" + zerotwoObject);
                zerotwoObject.rotation.y -= 0.01;
                var zerotwo = zerotwoObject.children[0];
                zerotwo.rotation.y -= 0.05;
             }

             // upgrade speed of zero two's rotations
             
             if (keyP) {
                for (var i=0; i<existingZeroTwoObjects.length; i++) {
                    var zerotwoObject = sceneElements.sceneGraph.getObjectByName(existingZeroTwoObjects[i].name);
                    zerotwoObject.rotation.y -= 0.01 * countSpeed;
                    var zerotwo = zerotwoObject.children[0];
                    zerotwo.rotation.y -= 0.05 * countSpeed;
                }
                countSpeed = countSpeed + 1;
             }

             if (keyM) {
                 console.log("here!");
                for (var i=0; i<existingZeroTwoObjects.length; i++) {
                    var zerotwoObject = sceneElements.sceneGraph.getObjectByName(existingZeroTwoObjects[i].name);
                    zerotwoObject.rotation.y -= countReduceSpeed/100;
                    var zerotwo = zerotwoObject.children[0];
                    zerotwo.rotation.y -= countReduceSpeed/100;
                }
                countReduceSpeed = countReduceSpeed/4;
             } 
             

        

            /*
            var zerotwo2 = sceneElements.sceneGraph.getObjectByName("zerotwo2");
            zerotwo2.rotation.y += 0.05;
            */

    // Change color of tree when mouse hover
    raycaster.setFromCamera( mouse, sceneElements.camera );
    
    // calculate objects intersecting the picking ray
    var array = sceneElements.sceneGraph.getObjectByName("center").children;
    
    // for (var i = 0; i < array.length; )

    var intersects = raycaster.intersectObjects( sceneElements.sceneGraph.getObjectByName("center").children);
    //console.log(intersects);

        

    if ( intersects.length > 0 && array.includes(intersects[0].object)) {
        intersects[0].object.material.color.set(0xadff2f);
        
    
    } else {
        for (var k = 0; k < array.length; k++) {
            array[k].material.color.set( 0x00472a);
        }
        
    
    }

    // change size of stones when hover
    for (var i=1; i<9; i++) {
        var arrayStone = sceneElements.sceneGraph.getObjectByName("center" + i).children;
        var intersectsStone = raycaster.intersectObjects( sceneElements.sceneGraph.getObjectByName("center" + i).children);
        
        if (intersectsStone.length > 0 && arrayStone.includes(intersectsStone[0].object) && intersectsStone[0].object.scale.y <= 1.7) {
            console.log("scale: " + intersectsStone[0].object.scale.y);
            console.log("intersectStone: " + intersectsStone[0].object);
            intersectsStone[0].object.scale.y += 0.2;
        } else if (intersectsStone.length > 0 && arrayStone.includes(intersectsStone[0].object) && intersectsStone[0].object.scale.y > 1.7) {
            intersectsStone[0].object.scale.y = 2.0;
        } else {
            for (var k=0; k<arrayStone.length; k++) {
                arrayStone[k].scale.set(1, 1, 1);
            }
            
        }
    }
        

            // Rendering
            helper.render(sceneElements);

            // NEW --- Update control of the camera
            sceneElements.control.update();

            // Call for the next frame
            requestAnimationFrame(computeFrame);
        }

        // STARTING

        init();

    </script>



</head>

<body>
    <div id="Tag3DScene"> </div>
</body>

</html>