<!DOCTYPE html>

<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title> 3D scene </title>

    <script type="module">

        import * as THREE from "https://threejs.org/build/three.module.js";

        import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";

        import { ConvexGeometry } from "https://threejs.org/examples/jsm/geometries/ConvexGeometry.js";

        // HELPER

        const helper = {

            initEmptyScene: function (sceneElements) {

                // initialize scene
                sceneElements.sceneGraph = new THREE.Scene();


                // initialize camera
                const width = window.innerWidth;
                const height = window.innerHeight;
                const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 500);
                sceneElements.camera = camera;
                

                // set camera position and look into the direction of the center of the scene
                camera.position.set(-30, 40, 50);
                camera.lookAt(new THREE.Vector3(0, 5, 10));

                // LIGHTS

                // ambient light
                
                var ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                sceneElements.sceneGraph.add(ambientLight);

                // directional light (to give some color to the stones)
                var dLight1 = new THREE.DirectionalLight(0xffffff);
                dLight1.name = "dLight1";
                dLight1.position.set(0, 1, 1).normalize;
                sceneElements.sceneGraph.add(dLight1);
            
                // pointlights (to illuminate each maze and give some blue-neon vibes)
                var pLightObject = new THREE.Object3D();
                pLightObject.name = "pLightObject";
                var pLight1 = new THREE.PointLight(0xffffbb, 25, 70);
                pLight1.name = "pLight1";
                pLight1.position.set(117, 20, 0);
                pLightObject.add(pLight1);

                var pLight2 = new THREE.PointLight(0xffffbb, 25, 70);
                pLight2.name = "pLight2";
                pLight2.position.set(-117, 20, 0);
                pLightObject.add(pLight2);

                var pLight3 = new THREE.PointLight(0xffffbb, 25, 70);
                pLight3.name = "pLight3";
                pLight3.position.set(0, 20, 117);
                pLightObject.add(pLight3);

                var pLight4 = new THREE.PointLight(0xffffbb, 25, 70);
                pLight4.name = "pLight4";
                pLight4.position.set(0, 20, -117);
                pLightObject.add(pLight4);

                sceneElements.sceneGraph.add(pLightObject);

                // hemisphere lights
                var hLight1 = new THREE.HemisphereLight(0xffffbb, 0x080820, 5); // "white light" (press W)
                sceneElements.sceneGraph.add(hLight1);
                hLight1.visible = false;
                hLight1.name = "hLight1";

                var hLight2 = new THREE.HemisphereLight(0xff0000, 0x000000, 100); // "red light" (press R)
                sceneElements.sceneGraph.add(hLight2);
                hLight2.visible = false;
                hLight2.name = "hLight2";

                // initialize renderer
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                sceneElements.renderer = renderer;
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setClearColor('rgb(0,51,102)', 1.0);
                renderer.setSize(width, height);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // add the rendered image in the HTML DOM
                const htmlElement = document.querySelector("#Tag3DScene");
                htmlElement.appendChild(renderer.domElement);

                // initialize orbitcontrols
                sceneElements.control = new OrbitControls(camera, renderer.domElement);
                sceneElements.control.screenSpacePanning = true;
            },

            render: function render(sceneElements) {
                sceneElements.renderer.render(sceneElements.sceneGraph, sceneElements.camera);
            },
        };

        // SCENE
        
        // store elements so that we can use them later in the animate function
        const sceneElements = {
            sceneGraph: null,
            camera: null,
            control: null,
            renderer: null,
        };

        // init function - it creates a new scene, creates each object and then renders the scene and its objects basically
        function init() {
            helper.initEmptyScene(sceneElements);
            load3DObjects(sceneElements.sceneGraph);
            requestAnimationFrame(animate);
        }

        // handling events 
        window.addEventListener('resize', resizeWindow);

        // available keys and added events
        var keyD = false, keyA = false, keyS = false, keyW = false, keyPlus = false, keyMinus = false, keyP = false, keyM = false, keyArrowUp = false, keyArrowDown = false, keyArrowLeft = false, keyArrowRight = false, keyShift = false, keyEnter = false, keyAlt = false, keyAltGr = false, keyW = false, keyR = false, keySpace = false, keyS = false, keyX = false, keyEsc = false, keyTab = false, keyBackSpace = false;
        document.addEventListener('keydown', onDocumentKeyDown, false);
        document.addEventListener('keyup', onDocumentKeyUp, false);
        document.addEventListener('mousemove', onDocumentMouseMove, false);

        // get mouse positions
        function onDocumentMouseMove(event) {
            event.preventDefault();

            // update the mouse variable
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        // update render image size and camera aspect when the window is resized
        function resizeWindow(eventParam) {
            const width = window.innerWidth;
            const height = window.innerHeight;

            sceneElements.camera.aspect = width / height;
            sceneElements.camera.updateProjectionMatrix();
            sceneElements.renderer.setSize(width, height);
        }

        // case when keys are pressed
        function onDocumentKeyDown(event) {
            switch (event.keyCode) {
                case 68: //d
                    keyD = true;
                    break;
                case 83: //s
                    keyS = true;
                    break;
                case 65: //a
                    keyA = true;
                    break;
                case 87: //w
                    keyW = true;
                    break;
                case 187: //+
                    keyPlus = true;
                    break;
                case 189: //-
                    keyMinus = true;
                    break;
                case 80: //P 
                    keyP = true;
                    break;
                case 77: //M
                    keyM = true;
                    break;
                case 38: // ArrowUp
                    keyArrowUp = true;
                    break;
                case 40: // ArrowDown
                    keyArrowDown = true;
                    break;
                case 37: // ArrowLeft
                    keyArrowLeft = true;
                    break;
                case 39: // ArrowRight
                    keyArrowRight = true;
                    break;
                case 16: // Shift (right one)
                    keyShift = true;
                    break;
                case 13: // Enter
                    keyEnter = true;
                    break;
                case 18: // Alt
                    keyAlt = true;
                    break;
                case 225: // AltGr
                    keyAltGr = true;
                    break;
                case 87: // W
                    keyW = true;
                    break;
                case 82: // R
                    keyR = true;
                    break;
                case 32: // Space
                    keySpace = true;
                    break;
                case 83: // S
                    keyS = true;
                    break;
                case 88: // X
                    keyX = true;
                    break;
                case 9: // Tab
                    keyTab = true;
                    break;
                case 27: // Esc
                    keyEsc = true;
                    break;
                case 8: // BackSpace
                    keyBackSpace = true;
                    break;
            }
        }

        // case when keys are not pressed
        function onDocumentKeyUp(event) {
            switch (event.keyCode) {
                case 68: //d
                    keyD = false;
                    break;
                case 83: //s
                    keyS = false;
                    break;
                case 65: //a
                    keyA = false;
                    break;
                case 87: //w
                    keyW = false;
                    break;
                case 187: //+
                    keyPlus = false;
                    break;
                case 189: //-
                    keyMinus = false;
                    break;
                case 80: //P 
                    keyP = false;
                    break;
                case 77: //M
                    keyM = false;
                    break;
                case 38: // ArrowUp
                    keyArrowUp = false;
                    break;
                case 40: // ArrowDown
                    keyArrowDown = false;
                    break;
                case 37: // ArrowLeft
                    keyArrowLeft = false;
                    break;
                case 39: // ArrowRight
                    keyArrowRight = false;
                    break;
                case 16: // Shift (right one)
                    keyShift = false;
                    break;
                case 13: // Enter
                    keyEnter = false;
                    break;
                case 18: // Alt
                    keyAlt = false;
                    break;
                case 225: // AltGr
                    keyAltGr = false;
                    break;
                case 87: // W
                    keyW = false;
                    break;
                case 82: // R
                    keyR = false;
                    break;
                case 32: // Space
                    keySpace = false;
                    break;
                case 83: // S
                    keyS = false;
                    break;
                case 88: // X
                    keyX = false;
                    break;
                case 9: // Tab
                    keyTab = false;
                    break;
                case 27: // Esc
                    keyEsc = false;
                    break;
                case 8: // BackSpace
                    keyBackSpace = false;
                    break;
            }
        }   
        // auxiliary functions to create a Zero Two Object

        function makeHeadSkeleton(color) { // the "head" of the puppet
            var radius =  1.0, tubeRadius =  5.0, radialSegments = 30, tubularSegments = 100;  
            var geometry = new THREE.TorusGeometry(radius, tubeRadius,radialSegments, tubularSegments);
            var material = new THREE.MeshBasicMaterial({color: color});
            var mesh = new THREE.Mesh(geometry, material);
            return mesh;
        }

        function makeHair() { // the hair
            var hair = new THREE.Group();
            var geometry = new THREE.BoxGeometry(0.5, 20, 8);
            var material = new THREE.MeshBasicMaterial({color: 0xffc0cb});
            var hair1 = new THREE.Mesh(geometry, material); // the big pink rectangle

            var shape = new THREE.Shape();
            shape.moveTo(5,0);
            shape.lineTo(0, 10);
            shape.lineTo(-5, 0);
            shape.lineTo(5, 0);

            var extrudeSettings = {steps: 2, depth: 0.01, bevelEnabled: true, bevelThickness: 1, bevelSize: 1, bevelOffset: 0, bevelSegments: 1}

            var shapeGeometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            var shapeMaterial = new THREE.MeshBasicMaterial({ color: 0xffc0cb });
            var shapeHair = new THREE.Mesh(shapeGeometry, shapeMaterial); // hair tips (the triangle)
            shapeHair.rotation.y = Math.PI/2;
            shapeHair.scale.set(1, 1.8, 1.3);
            shapeHair.position.y = -10;

            hair.add(hair1);
            hair.add(shapeHair);

            return hair;
        }

        // head function
        function createHead() {
            var head = new THREE.Group();

            // head/face
            var circle = makeHeadSkeleton(0xf7e7ce);

            // part of the hair on top of the head
            var beginHair = makeHeadSkeleton(0xffc0cb);
            beginHair.scale.set(0.9, 0.2, 1);
            beginHair.position.set(0, 5, -1);
            beginHair.rotation.x = -0.2;
            
            // hair
            var hair = makeHair();
            hair.rotation.y = Math.PI/2;
            hair.position.z = -4.8;
            hair.position.y = -6;

            // eyes
            var eyeShape = new THREE.Shape();
            eyeShape.moveTo( 0,0 );
            eyeShape.lineTo(0.5, 1);
            eyeShape.lineTo(1.5, 3);
            eyeShape.lineTo(3.5, 3);
            eyeShape.lineTo(5, 1);
            eyeShape.lineTo(5.5, 0);
            eyeShape.lineTo(3.5, 3);
            eyeShape.lineTo(1.5, 3);
            eyeShape.lineTo(0, 0);

            var extrudeSettings = {steps: 2, depth: 0.01, bevelEnabled: true, bevelThickness: 1, bevelSize: 1, bevelOffset: 0, bevelSegments: 1};

            var eyeGeometry = new THREE.ExtrudeGeometry(eyeShape, extrudeSettings);
            var eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            var eye1 = new THREE.Mesh(eyeGeometry, eyeMaterial) ;
            eye1.position.set(-4, 2.5, 4);
            eye1.rotation.y = -0.2;
            eye1.scale.set(0.3, 0.3, 0.3);

            var eye2 = new THREE.Mesh(eyeGeometry, eyeMaterial) ;
            eye2.position.set(3, 2.5, 4);
            eye2.rotation.y = 0.2;
            eye2.scale.set(0.3, 0.3, 0.3);

            // mouth
            var mouthShape = new THREE.Shape();
            mouthShape.moveTo(-1, 0);
            mouthShape.lineTo(1, 0);
            mouthShape.bezierCurveTo(0.2, -0.1, -0.2, -0.1, -1, 0);

            var mouthGeometry = new THREE.ExtrudeGeometry(mouthShape, extrudeSettings);
            var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);}); // each mouth will have a different/random color
            var mouthMaterial = new THREE.MeshBasicMaterial({color: randomColor})
            var mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.scale.set(0.5, 2, 0.5);
            mouth.position.set(0, 0, 5);

            // band on top of the head
            var bandGeometry = new THREE.BoxGeometry(8, 0.5, 1);
            var bandMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
            var band1 = new THREE.Mesh(bandGeometry, bandMaterial);
            band1.position.y = 6.2;

            // horns on top of the had, above the band
            var hornRadius =  1.0, hornHeight = 10.0, hornRadialSegments =  3;  
            var hornGeometry = new THREE.ConeGeometry(hornRadius, hornHeight, hornRadialSegments);
            var hornMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
            var horn1 = new THREE.Mesh(hornGeometry, hornMaterial);
            horn1.scale.set(1, 0.5, 1);
            horn1.position.set(2, 7, 0);

            var horn2 = new THREE.Mesh(hornGeometry, hornMaterial);
            horn2.scale.set(1, 0.5, 1);
            horn2.position.set(-2, 7, 0);
            
            // add every mesh to a group
            head.add(horn2);
            head.add(horn1);
            head.add(band1);
            head.add(mouth);
            head.add(eye1);
            head.add(eye2);
            head.add(circle);
            head.add(beginHair);
            head.add(hair);
            return head;
        }

        function createLathe(color) {
            var points = [];
            for (var i = 0; i < 5; i+=0.5) {
                points.push(new THREE.Vector3(i + 4, 0.5*i*i, 0));
            }

            for (var i = 11.125; i < 16; i++ ) {
                points.push(new THREE.Vector3(8.5, i + 0.1*i, 0));
            }

            points.push(new THREE.Vector3(8, 18.25, 0));
            points.push(new THREE.Vector3(7.5, 20.125, 0));
            points.push(new THREE.Vector3(7, 21.75, 0));
            points.push(new THREE.Vector3(6.5, 23.125, 0));
            points.push(new THREE.Vector3(6, 24.25, 0));
            points.push(new THREE.Vector3(5.5, 25.125, 0));
            points.push(new THREE.Vector3(5, 25.75, 0));
            points.push(new THREE.Vector3(4.5, 26.125, 0));
            points.push(new THREE.Vector3(4, 26.25, 0));

            var segments = 50, phiStart = Math.PI * 2.00, phiLength = Math.PI * 2.00;  
            var geometry = new THREE.LatheGeometry(points, segments, phiStart, phiLength);
            var material = new THREE.MeshPhongMaterial({color: color, wireframe: true});
            var lathe = new THREE.Mesh(geometry, material);
            return lathe;
        }

        function createComplexLeaf(color1, color2) {

            // initialize group
            var completeLeaf1 = new THREE.Group();

            // stem
            var stemGeometry = new THREE.CylinderGeometry(0.2, 0.2, 10, 50);
            var stemMaterial = new THREE.MeshBasicMaterial( {color: color1} );
            var stem1 = new THREE.Mesh(stemGeometry, stemMaterial);

            stem1.position.y = 30;
            completeLeaf1.add(stem1);

            // small leaves
            var leafShape = new THREE.Shape();
            leafShape.moveTo(0, 0);
            leafShape.bezierCurveTo(1, 2, 1, 3, 0, 4);
            leafShape.bezierCurveTo(-1, 3, -1, 2, 0, 0);

            var leafSettings = {steps: 2, depth: 0.5, bevelEnabled: false, bevelThickness: 1, bevelSize: 1, bevelOffset: 0, bevelSegments: 1};

            var leafGeometry = new THREE.ExtrudeGeometry(leafShape, leafSettings);
            var leafMaterial = new THREE.MeshBasicMaterial({color: color2});
            var leaf1 = new THREE.Mesh(leafGeometry, leafMaterial);
            leaf1.scale.set(1, 2, 1);
            leaf1.position.y = 34;

            // right side
            var leaf2 = new THREE.Mesh(leafGeometry, leafMaterial);
            leaf2.scale.set(1, 1.5, 1);
            leaf2.position.set(0, 34, 0);
            leaf2.rotation.z = -0.6;

            var leaf3 = new THREE.Mesh(leafGeometry, leafMaterial);
            leaf3.scale.set(1, 1.5, 1);
            leaf3.position.set(0, 32, 0);
            leaf3.rotation.z = -0.8;

            var leaf4 = new THREE.Mesh(leafGeometry, leafMaterial);
            leaf4.scale.set(1, 1.5, 1);
            leaf4.position.set(0, 29.5, 0);
            leaf4.rotation.z = -0.8;

            // left side
            var leaf5 = new THREE.Mesh(leafGeometry, leafMaterial);
            leaf5.scale.set(1, 1.5, 1);
            leaf5.position.set(0, 34, 0);
            leaf5.rotation.y = Math.PI;
            leaf5.rotation.z = -0.6;

            var leaf6 = new THREE.Mesh(leafGeometry, leafMaterial);
            leaf6.scale.set(1, 1.5, 1);
            leaf6.position.set(0, 32, 0);
            leaf6.rotation.y = Math.PI;
            leaf6.rotation.z = -0.8;

            var leaf7 = new THREE.Mesh(leafGeometry, leafMaterial);
            leaf7.scale.set(1, 1.5, 1);
            leaf7.position.set(0, 29.5, 0);
            leaf7.rotation.y = Math.PI;
            leaf7.rotation.z = -0.8;

            completeLeaf1.add(leaf7);
            completeLeaf1.add(leaf6);
            completeLeaf1.add(leaf5);
            completeLeaf1.add(leaf4);
            completeLeaf1.add(leaf3);
            completeLeaf1.add(leaf2);
            completeLeaf1.add(leaf1);

            completeLeaf1.rotation.y = Math.PI/2;
            return completeLeaf1;
        }

        // Zero Two's body function (torso, dress, legs, arms, feet, flashlight, ...)
        function createBody() {
            // initialize body group
            var body = new THREE.Group();

            // torso
            var geometry = new THREE.BoxGeometry(8, 4, 4);
            var material = new THREE.MeshBasicMaterial({color: 0xff0000});
            var torso = new THREE.Mesh(geometry, material);
            torso.rotation.z = Math.PI/2;
            torso.scale.set(2,2,2);
            body.add(torso);

            // dress - lathe geometry
            var points = [];
            for (var i = 0; i < 10; i++) {
                points.push(new THREE.Vector2(Math.cos(i * 0.2) * 3 + 3, (i - 5) * 0.8));
            }
            var latheGeometry = new THREE.LatheGeometry(points);
            var dress = new THREE.Mesh(latheGeometry, material);
            dress.scale.set(1.5, 3.5, 1.5);
            dress.position.y = -10;
            body.add(dress);

            // 1st forearm
            var forearmGeometry = new THREE.CylinderGeometry(2, 2, 20, 50);
            var forearm1 = new THREE.Mesh(forearmGeometry, material);
            forearm1.scale.set(1, 0.7, 1);
            forearm1.position.set(16, 13, 0);
            forearm1.rotation.z = -0.6;
            body.add(forearm1);

            // 2nd forearm
            var forearm2 = new THREE.Mesh(forearmGeometry, material);
            forearm2.scale.set(1, 0.7, 1);
            forearm2.position.set(-16, 13, 0);
            forearm2.rotation.z = 0.6;
            body.add(forearm2);

            // 1st arm
            var arm1 = new THREE.Mesh(forearmGeometry, material);
            arm1.scale.set(1, 0.3, 1);
            arm1.rotation.z = Math.PI/2;
            arm1.position.set(7, 6, 0);
            body.add(arm1);

            // 2nd arm
            var arm2 = new THREE.Mesh(forearmGeometry, material);
            arm2.scale.set(1, 0.3, 1);
            arm2.rotation.z = Math.PI/2;
            arm2.position.set(-7, 6, 0);
            body.add(arm2);

            // 1st sphere arm
            var sphereGeometry = new THREE.SphereGeometry(2, 32, 32);
            var sphereMaterial = new THREE.MeshBasicMaterial({color: 0x808080});
            var sphere1 = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere1.position.set(11, 6, 0);
            body.add(sphere1);

            // 2nd sphere arm
            var sphere2 = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere2.position.set(-11, 6, 0);
            body.add(sphere2);

            // 1st leg
            var legGeometry = new THREE.CylinderGeometry(1, 2, 30, 32);
            var legMaterial = new THREE.MeshBasicMaterial({color: 0x000000});
            var leg1 = new THREE.Mesh(legGeometry, legMaterial);
            leg1.position.set(-4, -30, 0);
            body.add(leg1);

            // 2nd leg
            var leg2 = new THREE.Mesh(legGeometry, legMaterial);
            leg2.position.set(4, -30, 0);
            body.add(leg2);

            // 1st boot
            var whiteMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
            var bootPoints = [];
            for ( var i = 0; i < 5; i ++ ) {
                bootPoints.push(new THREE.Vector2( 2, i));
            }
            var bootGeometry = new THREE.LatheGeometry(bootPoints);
            var boot1 = new THREE.Mesh(bootGeometry, whiteMaterial);
            boot1.position.set(4, -45, 0);
            body.add(boot1);

            // 2nd boot
            var boot2 = new THREE.Mesh(bootGeometry, whiteMaterial);
            boot2.position.set(-4, -45, 0);
            body.add(boot2);

            // 1st foot
            var shape = new THREE.Shape();
            shape.moveTo(-1, 0);
            shape.bezierCurveTo(-0.5, 0.25, 0.5, 0.25, 1, 0);
            shape.lineTo(-1, 0);

            var extrudeSettings = {steps: 20, depth: 3, bevelEnabled: true, bevelThickness: 1, bevelSize: 1, bevelOffset: 0, bevelSegments: 1};

            var footGeometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            var wireframeMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
            var foot1 = new THREE.Mesh(footGeometry, wireframeMaterial);
            foot1.scale.set(1, 2, 1.8);
            foot1.position.set(4, -47, -1);
            body.add(foot1);

            // 2nd foot
            var foot2 = new THREE.Mesh(footGeometry, wireframeMaterial);
            foot2.scale.set(1, 2, 1.8);
            foot2.position.set(-4, -47, -1);
            body.add(foot2);

            // HANDS
            // 1st wrist
            var skinMaterial = new THREE.MeshBasicMaterial({color: 0xf7e7ce});
            var wrist1 = new THREE.Mesh( forearmGeometry, skinMaterial );
            wrist1.scale.set(0.7, 0.2, 0.7);
            wrist1.position.set(21, 20, 0);
            wrist1.rotation.z = -0.6;
            body.add(wrist1);

            // 1st palm
            var palmRadius = 1.5, palmTubeRadius = 1.5, palmRadialSegments = 8, palmTubularSegments = 24;  
            var palmGeometry = new THREE.TorusGeometry(palmRadius, palmTubeRadius, palmRadialSegments, palmTubularSegments);
            var palm1 = new THREE.Mesh(palmGeometry, skinMaterial);
            palm1.position.set(23, 22, 0);
            palm1.rotation.x = Math.PI/2;
            body.add(palm1);

            // 2nd wrist
            var wrist2 = new THREE.Mesh( forearmGeometry, skinMaterial );
            wrist2.scale.set(0.7, 0.2, 0.7);
            wrist2.position.set(-21, 20, 0);
            wrist2.rotation.z = 0.6;
            body.add(wrist2);

            // 2nd palm
            var palm2 = new THREE.Mesh(palmGeometry, skinMaterial);
            palm2.position.set(-23, 22, 0);
            palm2.rotation.x = Math.PI/2;
            body.add(palm2);

            // Flashlight
            var flashlight1 = createLathe(0xffcc00);
            flashlight1.scale.set(0.4, 0.4, 0.4);
            flashlight1.position.set(23, 26, 0);
            body.add(flashlight1);

            var pointLight = new THREE.PointLight(0xffff00, 2, 25);
            pointLight.castShadow = true;
            pointLight.position.set(23, 26, 0);
            body.add(pointLight);

            // Holder
            var holderRadiusTop =  1.3, holderRadiusBottom =  0.7, holderHeight = 12, holderRadialSegments = 12;  
            var holderGeometry = new THREE.CylinderGeometry(holderRadiusTop, holderRadiusBottom, holderHeight, holderRadialSegments);
            var holderMaterial = new THREE.MeshBasicMaterial({color: 0x312113});
            var holder1 = new THREE.Mesh(holderGeometry, holderMaterial);
            holder1.position.set(23, 20, 0);
            body.add(holder1);

            // Neck
            var neck1 = new THREE.Mesh(forearmGeometry, skinMaterial);
            neck1.position.set(0, 5, 0);
            body.add(neck1);

            // Arrows (dress)
            var arrowShape = new THREE.Shape();
            arrowShape.moveTo(1, 0);
            arrowShape.lineTo(2, 0);
            arrowShape.lineTo(1.5, 1.5);
            arrowShape.lineTo(2, 3);
            arrowShape.lineTo(1, 3);
            arrowShape.lineTo(0.5, 1.5);
            arrowShape.lineTo(1, 0);

            var ArrowExtrudeSettings = {steps: 2, depth: 0.5, bevelEnabled: false, bevelThickness: 1, bevelSize: 1, bevelOffset: 0, bevelSegments: 1};

            var arrowGeometry = new THREE.ExtrudeGeometry(arrowShape, ArrowExtrudeSettings);
            var arrowMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            var arrow1 = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrow1.scale.set(1, 0.5, 1);
            arrow1.position.set(1, -1, 3.7);

            var arrowEdges = new THREE.EdgesGeometry(arrowGeometry);
            var arrowLine1 = new THREE.LineSegments(arrowEdges, new THREE.LineBasicMaterial({color: 0x000000}));
            arrowLine1.scale.set(1, 0.5, 1);
            arrowLine1.position.set(1, -1, 3.7);

            body.add(arrow1);
            body.add(arrowLine1);

            var arrow2 = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrow2.scale.set(1, 0.5, 1);
            arrow2.position.set(-1, -1, 4.2);
            arrow2.rotation.y = Math.PI;
            var arrowLine2 = new THREE.LineSegments(arrowEdges, new THREE.LineBasicMaterial({color: 0x000000}));
            arrowLine2.scale.set(1, 0.5, 1);
            arrowLine2.position.set(-1, -1, 4.2);
            arrowLine2.rotation.y = Math.PI;

            body.add(arrow2);
            body.add(arrowLine2);

            var arrowMaterial2 = new THREE.MeshBasicMaterial({color: 0xb8860b});
            var arrow3 = new THREE.Mesh(arrowGeometry, arrowMaterial2);
            arrow3.scale.set(0.8, 0.4, 1);
            arrow3.position.set(0, -1, 3.7);
            var arrowLine3 = new THREE.LineSegments(arrowEdges, new THREE.LineBasicMaterial({color: 0x000000}));
            arrowLine3.scale.set(0.8, 0.4, 1);
            arrowLine3.position.set(0, -1, 3.7);

            var arrow4 = new THREE.Mesh(arrowGeometry, arrowMaterial2);
            arrow4.scale.set(0.8, 0.4, 1);
            arrow4.rotation.y = Math.PI;
            arrow4.position.set(0, -1, 4.2);
            var arrowLine4 = new THREE.LineSegments(arrowEdges, new THREE.LineBasicMaterial({color:0x000000}));
            arrowLine4.scale.set(0.8, 0.4, 1);
            arrowLine4.rotation.y = Math.PI;
            arrowLine4.position.set(0, -1, 4.2);

            body.add(arrow3);
            body.add(arrow4);
            body.add(arrowLine3);
            body.add(arrowLine4);

            // belt
            var beltPoints = [];
            for (let i = 4; i < 6; ++i) {
                beltPoints.push(new THREE.Vector2(7, i));
            }
            var beltGeometry = new THREE.LatheGeometry(beltPoints);
            var beltMaterial = new THREE.MeshBasicMaterial({color: 0x654321});
            var belt1 = new THREE.Mesh(beltGeometry, beltMaterial);
            belt1.scale.set(0.85, 0.85, 0.6);
            belt1.position.set(0, -4.3, -0.7);
            body.add(belt1);

            // collar
            var collarGeometry = new THREE.BoxGeometry(5, 5, 5);
            var collarMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
            var collar1 = new THREE.Mesh(collarGeometry, collarMaterial);
            body.add(collar1);
            collar1.position.set(0, 10, 0);

            // tie
            var tieShape = new THREE.Shape();
            tieShape.moveTo(2, 2);
            tieShape.lineTo(3, 1);
            tieShape.lineTo(4, 2);
            tieShape.lineTo(3, 5);
            tieShape.lineTo(3.5, 5.5);
            tieShape.lineTo(3, 6);
            tieShape.lineTo(2.5, 5.5);
            tieShape.lineTo(3, 5);
            tieShape.lineTo(2, 2);
            

            var tieSettings = {steps: 2, depth: 0.5, bevelEnabled: false, bevelThickness: 1, bevelSize: 1, bevelOffset: 0, bevelSegments: 1};

            var tieGeometry = new THREE.ExtrudeGeometry(tieShape, tieSettings);
            var tieMaterial = new THREE.MeshBasicMaterial({color: 0xffa500});
            var tie1 = new THREE.Mesh(tieGeometry, tieMaterial);
            tie1.scale.set(0.9, 0.9, 0.9);
            tie1.position.set(-2.75, 7.1, 2.5);

            body.add(tie1);

            // COMPLETE LEAF
            var completeLeaf1 = createComplexLeaf(0x006400, 0x149414); // green leaf at the base of the flashlight
            completeLeaf1.position.set(0, 0, 0);
            completeLeaf1.scale.set(0.7, 0.7, 0.7);
            completeLeaf1.rotateOnWorldAxis(new THREE.Vector3(0,0,1), -0.9);
            completeLeaf1.position.set(9, 12.5, 0);
            
            var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);}); // each flying leaf will have a random color too!
            var completeLeaf2 = createComplexLeaf(randomColor, randomColor);
            completeLeaf2.translateZ(-100).translateY(-10);
            completeLeaf2.rotation.z = -0.6;
            completeLeaf2.rotation.y = Math.PI/2;

            body.add(completeLeaf2);
            body.add(completeLeaf1);

            return body;
        }


        // create the whole Zero Two's puppet (head + body)
        function createZeroTwo() {
            var zerotwo1 = new THREE.Group();
            var head1 = createHead();
            head1.position.x = 0;

            var body1 = createBody();
            body1.position.x = 0;
            body1.position.y = -20;
            
            zerotwo1.add(head1);
            zerotwo1.add(body1);
            return zerotwo1;
        }

        // multiple pieces make a tree
        function createPiece(color) {
            var shape = new THREE.Shape();
            shape.moveTo(-0.5, 0);
            shape.lineTo(0, 1);
            shape.lineTo(0.5, 0);
            shape.bezierCurveTo(0.2, -0.1, -0.2, -0.1, -0.5, 0);
            
            var extrudeSettings = {steps: 2, depth: 0.05, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1, bevelSegments: 0};

            var geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            var material = new THREE.MeshBasicMaterial({color: color});
            var mesh = new THREE.Mesh(geometry, material);
            return mesh;
        }

        // Auxiliary functions to make a stone 

        // function that generates multiple points that will be necessary to make a ConvexGeometry
        function generatePoints() {    
            var points = [];
            for (var i = 0; i < 25; i++) {
                var randomX = Math.round(Math.random() * 4), randomY = Math.round(Math.random() * 25), randomZ = Math.round(Math.random() * 4);
                points.push(new THREE.Vector3(randomX, randomY, randomZ));
            }
            return points;
        }

        // function that checks if at least 3 points have y coordinate = 0 (so that there is a plane on the ground - with at least 3 points it's possible to make a plane)
        function goodPointsArray(array) {
            var count = 0;
            for (var i = 0; i < array.length; i++) {
                var point = array[i];
                if (point.y == 0) {
                    count = count + 1;
                }
            }

            if (count >= 3) {
                return true;
            } else {
                return false;
            }
        }

        // function that makes a stone
        function makeStone() {

            var points = generatePoints();
            var bool = goodPointsArray(points);

            while (!bool) {
            points = generatePoints();
            bool = goodPointsArray(points);
            }

            var material = new THREE.MeshLambertMaterial({color: "rgb(128,128,128)", transparent: true});
            var meshGeometry = new ConvexGeometry(points);

            var stone = new THREE.Mesh(meshGeometry, material);
            stone.castShadow = true;
            return stone;
        }

        function createMazeRowsFirstLast(possibleValuesRow, maze, position) {
            var boxGeometry = new THREE.BoxGeometry(10, 10, 10);
            var count = 0;
            while (count < 8) {
                var boxMaterial = new THREE.MeshPhongMaterial({color: 0x0B5345});
                var itemX = possibleValuesRow[Math.floor(Math.random() * possibleValuesRow.length)];
                var box = new THREE.Mesh(boxGeometry, boxMaterial);
                var edges = new THREE.EdgesGeometry(boxGeometry);
                var line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color: 0xFFD700}));
                box.position.set(itemX, 5, position);
                line.position.set(itemX, 5, position);
                for(var i = 0; i < possibleValuesRow.length; i++){ 
                    if (possibleValuesRow[i] === itemX) { 
                        possibleValuesRow.splice(i, 1); 
                        i--; 
                    }
                }
                maze.add(box);
                maze.add(line);
                count = count + 1;
            }
        }
        function createMazeRows(possibleValuesRow, possibleNumberBoxes, maze, position, phongmaterial=false) {
            // instantiate box geometry
            if (!phongmaterial) {
                var boxMaterial = new THREE.MeshBasicMaterial({color: 0x0B5345});
            } else {
                var boxMaterial = new THREE.MeshPhongMaterial({color: 0x0B5345});
            }
            var boxGeometry = new THREE.BoxGeometry(10, 10, 10);
            var numberBoxes = possibleNumberBoxes[Math.floor(Math.random() * possibleNumberBoxes.length)];
            for (var k=0; k < numberBoxes; k++) {
                var itemX = possibleValuesRow[Math.floor(Math.random() * possibleValuesRow.length)];
                var box = new THREE.Mesh(boxGeometry, boxMaterial);
                var edges = new THREE.EdgesGeometry(boxGeometry);
                var line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color: 0xFFD700}));
                box.position.set(itemX, 5, position);
                line.position.set(itemX, 5, position);
                for( var i = 0; i < possibleValuesRow.length; i++){ 
                    if (possibleValuesRow[i] === itemX) { 
                        possibleValuesRow.splice(i, 1); 
                        i--; 
                    }
                }
                maze.add(box);
                maze.add(line);
            }
        }

        // function that creates a maze
        function createMaze() {

            // initialize group
            var maze = new THREE.Group();

            // make a plane/ground
            var planeGeometry = new THREE.PlaneGeometry( 100, 100, 32 );
            var planeMaterial = new THREE.MeshBasicMaterial( {color: 0x567d46, side: THREE.DoubleSide} );
            var plane1 = new THREE.Mesh(planeGeometry, planeMaterial);
            plane1.position.set(0, -0.1, 100);
            plane1.rotation.x = Math.PI/2;
            
            // 1st row
            var xPossibleValues1stRow = [-45, -35, -25, -15, 15, 25, 35, 45];
            createMazeRowsFirstLast(xPossibleValues1stRow, maze, 55);
            
            // 2nd row
            var xPossibleValues2ndRow = [-45, -35, -25, -15, 15, 25, 35, 45];
            var possibleNumberBoxes = [4, 5, 6, 7, 8];
            createMazeRows(xPossibleValues2ndRow, possibleNumberBoxes, maze, 65);

            // 3rd row
            var xPossibleValues3rdRow = [-45, -35, -25, 25, 35, 45];
            var possibleNumberBoxes = [4, 5, 6, 7, 8];
            createMazeRows(xPossibleValues3rdRow, possibleNumberBoxes, maze, 75, true);

            // 4th row
            var xPossibleValues4thRow = [-45, -35, -25, -5, 5, 25, 35, 45];
            var possibleNumberBoxes = [4, 5, 6, 7, 8];
            createMazeRows(xPossibleValues4thRow, possibleNumberBoxes, maze, 85);

            // 5th row
            var xPossibleValues5thRow = [-45, -5, 5, 45];
            var possibleNumberBoxes = [4, 5, 6, 7, 8];
            createMazeRows(xPossibleValues5thRow, possibleNumberBoxes, maze, 95, true);

            // 6th row
            var xPossibleValues6thRow = [-45, -25, -15, -5, 5, 15, 25, 45];
            var possibleNumberBoxes = [4, 5, 6, 7, 8];
            createMazeRows(xPossibleValues6thRow, possibleNumberBoxes, maze, 105);

            // 7th row
            var xPossibleValues7thRow = [-45, -5, 5, 45];
            var possibleNumberBoxes = [4, 5, 6, 7, 8];
            createMazeRows(xPossibleValues7thRow, possibleNumberBoxes, maze, 115, true);

            // 8th row
            var xPossibleValues8thRow = [-45, -35, -25, -5, 5, 25, 35, 45];
            var possibleNumberBoxes = [4, 5, 6, 7, 8];
            createMazeRows(xPossibleValues8thRow, possibleNumberBoxes, maze, 125);

            // 9th row
            var xPossibleValues9thRow = [-45, -35, -25, 25, 35, 45];
            var possibleNumberBoxes = [4, 5, 6, 7, 8];
            createMazeRows(xPossibleValues9thRow, possibleNumberBoxes, maze, 135, true);

            // 10th row
            var xPossibleValues10thRow = [-45, -35, -25, -15, 15, 25, 35, 45];
            createMazeRowsFirstLast(xPossibleValues10thRow, maze, 145);

            maze.add(plane1);

            return maze;
        }

        // function that creates the cross at the center of the scene
        function createCelticCross() {
            // initialize group
            var cross = new THREE.Group();
            cross.position.set(0, 20, 0);

            // circle
            var circleRadius =  7.5, circleTubeRadius =  2.0, circleRadialSegments = 30, circleTubularSegments = 100;  
            var circleGeometry = new THREE.TorusGeometry(circleRadius, circleTubeRadius, circleRadialSegments, circleTubularSegments);;
            var crossMaterial = new THREE.MeshToonMaterial({color: 0x49311d});
            var circle = new THREE.Mesh(circleGeometry, crossMaterial);
            circle.position.y = 36;
            cross.add(circle);

            // cross in the middle
            var middleCrossShape = new THREE.Shape();
            middleCrossShape.moveTo(-2, 0);
            middleCrossShape.lineTo(2, 0);
            middleCrossShape.lineTo(4, 5);
            middleCrossShape.lineTo(-4, 5);
            middleCrossShape.lineTo(-2, 0);

            var middleCrossSettings = {steps: 2, depth: 2, bevelEnabled: false, bevelThickness: 1, bevelSize: 1, bevelOffset: 0, bevelSegments: 1};

            var middleCrossGeometry = new THREE.ExtrudeGeometry(middleCrossShape, middleCrossSettings);

            // creating the components of the cross in the middle of the circle/ring
            var middleCross1 = new THREE.Mesh(middleCrossGeometry, crossMaterial);
            middleCross1.scale.set(0.7, 1, 1);
            middleCross1.position.y = 1;
            var middleCross2 = new THREE.Mesh(middleCrossGeometry, crossMaterial);
            middleCross2.scale.set(0.7, 1, 1);
            middleCross2.position.x = -1;
            var middleCross3 = new THREE.Mesh(middleCrossGeometry, crossMaterial);
            middleCross3.scale.set(0.7, 1, 1);
            middleCross3.position.y = -1;
            var middleCross4 = new THREE.Mesh(middleCrossGeometry, crossMaterial);
            middleCross4.scale.set(0.7, 1, 1);
            middleCross4.position.x = 1;
            var middleCross5 = new THREE.Mesh(middleCrossGeometry, crossMaterial);
            middleCross5.scale.set(0.4, 0.7, 1);
            middleCross5.position.y = -1.7;

            middleCross2.rotation.z = Math.PI/2;
            middleCross3.rotation.z = Math.PI;
            middleCross4.rotation.z = -Math.PI/2;

            // adding all this pieces to a major group
            var middleCross = new THREE.Group();
            middleCross.position.y = 36;
            middleCross.add(middleCross1);
            middleCross.add(middleCross2);
            middleCross.add(middleCross3);
            middleCross.add(middleCross4);
            middleCross.add(middleCross5);

            cross.add(middleCross);

            // base
            var baseShape = new THREE.Shape();
            baseShape.moveTo(-2, 0);
            baseShape.lineTo(2, 0);
            baseShape.bezierCurveTo(1.8, 3, 1.5, 5, 1, 8);
            baseShape.lineTo(-1, 8);
            baseShape.bezierCurveTo(-1.5, 5, -1.8, 3, -2, 0);

            var baseGeometry = new THREE.ExtrudeGeometry(baseShape, middleCrossSettings);
            var base = new THREE.Mesh(baseGeometry, crossMaterial);
            base.position.set(0, -20, -1);
            base.scale.set(2.5, 6, 1);

            cross.add(base);

            // top (reusing base and scaling it)
            var top = new THREE.Mesh(baseGeometry, crossMaterial);
            top.rotation.z = Math.PI;
            top.position.y = 50;
            top.scale.set(1.5, 2, 1);

            cross.add(top);
            return cross;
        }

        // auxiliary function for creating rain
        function randomIntFromInterval(min, max) { // min and max included 
        return Math.floor(Math.random() * (max - min + 1) + min);
        }

        // function that creates multiple little boxes that reproduce rain
        function createRain(number) {
            var rainElements = new THREE.Group();
            for (var i = 0; i < number; i++) {
                var size = Math.random()/2;
                var rainGeometry = new THREE.BoxGeometry(size, size, size);
                var rainMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
                var rain = new THREE.Mesh(rainGeometry, rainMaterial);
                rain.position.set(randomIntFromInterval(1, 150), randomIntFromInterval(1, 60), randomIntFromInterval(1, 150));
                while (rain.position.x > 50 && rain.position.z > 50) {
                    rain.position.set(randomIntFromInterval(1, 150), randomIntFromInterval(1, 60), randomIntFromInterval(1, 150));
                }
                rainElements.add(rain);
            }
            return rainElements;
        }

        // function similar to createRain, but in this one, we're creating little boxes to reproduce fire sparkles
        function createFire() {
            var fireElements = new THREE.Group();

            // creating 100 blocks/boxes
            for (var i = 0; i < 100; i++) {
                var fireGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                var fireMaterial = new THREE.MeshBasicMaterial({color: 0xff7700});
                var fire = new THREE.Mesh(fireGeometry, fireMaterial);
                fire.position.set(randomIntFromInterval(0, 12), randomIntFromInterval(1, 45), 2); //more than half the height of the cross, width of the cross
                fireElements.add(fire);

                // half of the blocks are invisible, and these are where the visibility of the blocks will be constantly changing between visible and invisible
                if (i>=50) {
                    fire.visible = false;
                }   
            }
            return fireElements;
        }

        // create tree function (with multiple pieces created with an extrude)
        function createTree() {
            var center = new THREE.Object3D();

            // create 100 pieces for 4 floors and "rotate" them
            for (var i=0; i<100; i++) {
                var piece = createPiece(0x00472a);
                center.add(piece);
                piece.position.set(Math.cos(1 + i*0.1), 1, Math.sin(1 + i*0.1))

                var piece2 = createPiece(0x00472a);
                center.add(piece2);
                piece2.position.set(Math.cos(1 + i*0.1)/1.1, 2, Math.sin(1 + i*0.1)/1.1);

                var piece3 = createPiece(0x00472a);
                center.add(piece3);
                piece3.position.set(Math.cos(1 + i*0.1)/1.2, 3, Math.sin(1 + i*0.1)/1.2);

                var piece4 = createPiece(0x00472a);
                center.add(piece4);
                piece4.position.set(Math.cos(1 + i*0.1)/1.3, 4, Math.sin(1 + i*0.1)/1.3);
            }

            // top of tree (cone)
            for (var i=0; i<400; i++) {;
                var piece = createPiece(0x00472a);
                piece.scale.set(1.3, 1.3, 1.3);
                center.add(piece);
                piece.position.y = 5.2;
                piece.rotation.y = THREE.Math.degToRad(i);
            }
            center.scale.set(2, 2 , 2);
            return center;
        }

        function createTreeBase() {
            // base of tree (cylinder)
            var baseGeometry = new THREE.CylinderGeometry(3, 3, 10, 32);
            var baseMaterial = new THREE.MeshBasicMaterial({color: 0x341c02});
            var cylinder = new THREE.Mesh(baseGeometry, baseMaterial);
            return cylinder;
        }
        
        var existingZeroTwoObjects = [];
        var removedZeroTwoObjects = [];

        // Create and insert in the scene graph the models of the 3D scene
        function load3DObjects(sceneGraph) {

            // plane at the center of the scene
            const pgeometry = new THREE.PlaneGeometry(100, 100, 32);
            const pmaterial = new THREE.MeshPhongMaterial({color: 0x567d46, side: THREE.DoubleSide});
            const plane = new THREE.Mesh(pgeometry, pmaterial);
            plane.rotation.x = Math.PI / 2;
            plane.receiveShadow = true;
            sceneGraph.add(plane);

            // initialize axisHelper
            var axes = new THREE.AxisHelper(500);  
            sceneGraph.add(axes);

            // Create stones
            for (var st=1; st < 5; st++) {
                var stone = makeStone();
                var center = new THREE.Object3D();
                center.name = "center" + st;
                center.add(stone);
                sceneGraph.add(center);
                if (st == 1) {
                    stone.position.x = 30;
                } else if (st == 2) {
                    stone.position.x = -30;
                } else if (st == 3) {
                    stone.position.z = 30;
                } else {
                    stone.position.z = -30;
                }
                
            }

            // Rotated stones (midpoints)
            for (var i = 5; i < 9; i++) {
                var stone = makeStone();
                stone.name = "stone" + i;
                var center = new THREE.Object3D();
                center.name = "center" + i;
                center.add(stone);
                sceneGraph.add(center);
                stone.position.set(30*Math.cos(Math.PI/4 + i*(Math.PI/2)), 0, 30*Math.sin(Math.PI/4 + i*(Math.PI/2)))
            }
        
        // Make zero two character

        // Create and rotate 8 zero twos
        for (var i = 1; i < 9; i++) {
            var zerotwo = createZeroTwo();
            var rotateZeroTwo = new THREE.Object3D();

            rotateZeroTwo.add(zerotwo);

            zerotwo.scale.set(0.2, 0.2, 0.2);
            zerotwo.position.set(20, 13.5, 0);

            zerotwo.name = "zerotwo" + i;
            rotateZeroTwo.name = "rotateZeroTwo" + i;

            rotateZeroTwo.rotation.y = i*(Math.PI/4);
            sceneGraph.add(rotateZeroTwo);

            existingZeroTwoObjects.push(rotateZeroTwo);
        }

        // Create trees
        for (var t = 1; t < 5; t++) {
            var tree1 = createTree();
            tree1.name = "tree" + t;
            tree1.scale.set(5, 5, 5);
            sceneGraph.add(tree1);
            var treeBase1 = createTreeBase();
            sceneGraph.add(treeBase1);

            if (t == 1) {
                tree1.position.set(-35, 5, -40);
                treeBase1.position.set(-35, 4, -40);
            } else if (t == 2) {
                tree1.position.set(35, 5, -40);
                treeBase1.position.set(35, 4, -40);
            } else if (t == 3) {
                tree1.position.set(35, 5, 40);
                treeBase1.position.set(35, 4, 40);
            } else {
                tree1.position.set(-35, 5, 40);
                treeBase1.position.set(-35, 4, 40);
            }
            
        }
        

        // Create celtic cross in the middle of the scene
        var cross1 = createCelticCross();
        sceneGraph.add(cross1);

        // Initialize cylinder parameters (object that will move around the maze)
        var cylinderTop =  1.5, cylinderBottom =  1.5, cylinderHeight = 5, cylinderSegments = 12;  
        var cylinderGeometry = new THREE.CylinderGeometry(cylinderTop, cylinderBottom, cylinderHeight, cylinderSegments);

        // Create rain and fire objects
        for (var j = 1; j < 5; j++) {
            // create mazes
            var maze = createMaze();
            var mazeObject = new THREE.Object3D();
            mazeObject.add(maze);
            mazeObject.rotation.y = Math.PI/2 * (j-1);
            sceneGraph.add(mazeObject);

            // create cylinders that will move around the mazes
            var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);}); // each cylinder will have a different and random color
            var cylinderMaterial = new THREE.MeshBasicMaterial({color: randomColor});
            var cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
            cylinder.position.set(0, 2.5, 148);
            cylinder.name = "cylinder" + i;
            var cylinderObject3D = new THREE.Object3D();
            cylinderObject3D.add(cylinder);
            sceneGraph.add(cylinderObject3D);
            cylinderObject3D.rotation.y = Math.PI/2 * j;
            cylinderObject3D.name = "cylinderObject3D" + j;

            // rain
            
            var bigRain = createRain(400);
            var rainObject3D = new THREE.Object3D();
            rainObject3D.add(bigRain);
            sceneGraph.add(rainObject3D);
            rainObject3D.name = "rainObject3D" + j;
            rainObject3D.rotation.y = (i-1) * Math.PI/2;
            
            // fire
            var fireObject = new THREE.Object3D();
            fireObject.name = "fireObject" + j;
            var fire = createFire();
            fire.position.set(-6, 0, 6);
            fire.name = "fire" + j;
            sceneGraph.add(fireObject);
            fireObject.add(fire);
            fireObject.rotation.y = j * Math.PI/2;
        }
    }
    

        // ANIMATING
        var delta = 0.1, dispX = 0.2, dispZ = 0.2, countSpeed = 0, countReduceSpeed = 0.01, cameraFlag = true, animateZeroTwoFlag = true;

        // initialize raycaster and "mouse coordinates"
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2(0.1, 0.1); 

        function animateRain(rainName, rotation) {
            var bigRain1 = sceneElements.sceneGraph.getObjectByName(rainName).children[0];
            bigRain1.rotation.y = rotation;
        var rainElementsArray = bigRain1.children;
        for (var j = 0; j < rainElementsArray.length; j++) {
            var element = rainElementsArray[j];
            if (element.position.y > -1) {
                element.position.y -= 0.2;
            } else {
                element.position.y = 65;
            }  
        }
        }

        function animateZeroTwos(stoneNumber) {
            for (var z2 = 0; z2 < existingZeroTwoObjects.length; z2++) {
                    var zerotwoObject = sceneElements.sceneGraph.getObjectByName(existingZeroTwoObjects[z2].name);
                    var stone = sceneElements.sceneGraph.getObjectByName("center" + stoneNumber).children[0];
                    zerotwoObject.position.set(stone.position.x, 0, stone.position.z);
                    var zerotwo = zerotwoObject.children[0];
                    zerotwo.position.set(12, 13.5, 0);
                }
        }

        // animate function
        function animate(time) {

            // Animate Point Lights
            var pLight = sceneElements.sceneGraph.getObjectByName("pLightObject");
            pLight.rotation.y += 0.1;

            // Animate rain
            
            animateRain("rainObject3D1", 0);
            animateRain("rainObject3D2", Math.PI/2);
            animateRain("rainObject3D3", Math.PI);
            animateRain("rainObject3D4", 3*Math.PI/2);
            

            // Animate fire (at the center)

            for (var f = 1; f < 5; f++) {
                var fire1 = sceneElements.sceneGraph.getObjectByName("fireObject" + f).children[0];
                var fireElementsArray = fire1.children;
                for (var j = 0; j < fireElementsArray.length; j++) {
                    var fireElement = fireElementsArray[j];
                    if (fireElement.visible == true) {
                        fireElement.visible = false;
                    } else {
                        fireElement.visible = true;
                    }
                }
            }
        
            // Enable/disable rain
            if (keyS) {
                var bigRain1 = sceneElements.sceneGraph.getObjectByName("rainObject3D1").children[0];
                bigRain1.visible = false;
                var bigRain2 = sceneElements.sceneGraph.getObjectByName("rainObject3D2").children[0];
                bigRain2.visible = false;
                var bigRain3 = sceneElements.sceneGraph.getObjectByName("rainObject3D3").children[0];
                bigRain3.visible = false;
                var bigRain4 = sceneElements.sceneGraph.getObjectByName("rainObject3D4").children[0];
                bigRain4.visible = false;
            } else if (keyX) {
                var bigRain1 = sceneElements.sceneGraph.getObjectByName("rainObject3D1").children[0];
                bigRain1.visible = true;
                var bigRain2 = sceneElements.sceneGraph.getObjectByName("rainObject3D2").children[0];
                bigRain2.visible = true;
                var bigRain3 = sceneElements.sceneGraph.getObjectByName("rainObject3D3").children[0];
                bigRain3.visible = true;
                var bigRain4 = sceneElements.sceneGraph.getObjectByName("rainObject3D4").children[0];
                bigRain4.visible = true;
            }

            // ANIMATE STONES

            // change size of stones when hover
            for (var i=1; i<9; i++) {
                var arrayStone = sceneElements.sceneGraph.getObjectByName("center" + i).children;
                var intersectsStone = raycaster.intersectObjects( sceneElements.sceneGraph.getObjectByName("center" + i).children);
                
                if (intersectsStone.length > 0 && arrayStone.includes(intersectsStone[0].object) && intersectsStone[0].object.scale.y <= 1.7) {
                    intersectsStone[0].object.scale.y += 0.2;
                } else if (intersectsStone.length > 0 && arrayStone.includes(intersectsStone[0].object) && intersectsStone[0].object.scale.y > 1.7) {
                    intersectsStone[0].object.scale.y = 2.0;
                } else {
                    for (var k=0; k<arrayStone.length; k++) {
                        arrayStone[k].scale.set(1, 1, 1);
                    }
                    
                }
            }

            // ANIMATE ZERO TWO

            // dynamically remove zero twos
            if (keyMinus && existingZeroTwoObjects.length > 0) {
                var randomItem = existingZeroTwoObjects[existingZeroTwoObjects.length - 1];
                removedZeroTwoObjects.push(randomItem);
                sceneElements.sceneGraph.remove(randomItem);
                existingZeroTwoObjects.pop(randomItem);
            } else if (keyPlus && existingZeroTwoObjects.length <=8 && removedZeroTwoObjects.length != 0) {
                var object = removedZeroTwoObjects[removedZeroTwoObjects.length - 1];
                sceneElements.sceneGraph.add(object);
                removedZeroTwoObjects.pop(object);
                existingZeroTwoObjects.push(object);
            }
            
             // rotate zero twos
            if (!keyAlt && !keyAltGr) {
                for (var i=0; i<existingZeroTwoObjects.length; i++) {
                    var zerotwoObject = sceneElements.sceneGraph.getObjectByName(existingZeroTwoObjects[i].name);
                    zerotwoObject.rotation.y -= 0.02;
                    var zerotwo = zerotwoObject.children[0];
                    zerotwo.rotation.y -= 0.1;
                }
            } else if (keyAlt) {
                keyAltGr = false;
                for (var i=0; i<existingZeroTwoObjects.length; i++) {
                    var zerotwoObject = sceneElements.sceneGraph.getObjectByName(existingZeroTwoObjects[i].name);
                    zerotwoObject.rotation.y -= 0.06;
                    var zerotwo = zerotwoObject.children[0];
                    zerotwo.rotation.y -= 0.3;
                } 
            } else if (keyAltGr) {
                for (var i=0; i<existingZeroTwoObjects.length; i++) {
                    var zerotwoObject = sceneElements.sceneGraph.getObjectByName(existingZeroTwoObjects[i].name);
                    zerotwoObject.rotation.y += 0.04;
                    var zerotwo = zerotwoObject.children[0];
                    zerotwo.rotation.y += 0.2;
                }
            } 

            // make each zero two turn into a stone when pressing Shift
            if (keyShift) {
                var stoneNumber = 1;
                for (var z2 = 0; z2 < existingZeroTwoObjects.length; z2++) {
                    var zerotwoObject = sceneElements.sceneGraph.getObjectByName(existingZeroTwoObjects[z2].name);
                    var stone = sceneElements.sceneGraph.getObjectByName("center" + stoneNumber).children[0];
                    zerotwoObject.position.set(stone.position.x, 0, stone.position.z);
                    var zerotwo = zerotwoObject.children[0];
                    zerotwo.position.set(8.5, 13.5, 0);
                    stoneNumber++;
                }
            } else  if (keyEnter) { // go to the default positions and rotations (turn around the scene's center)
                for (var z2=0; z2<existingZeroTwoObjects.length; z2++) {
                    var zerotwoObject = sceneElements.sceneGraph.getObjectByName(existingZeroTwoObjects[z2].name);
                    zerotwoObject.position.set(0, 0, 0);
                    var zerotwo = zerotwoObject.children[0];
                    zerotwo.position.set(20, 13.5, 0);
                }
            } else if (keyBackSpace) {
                animateZeroTwos(randomIntFromInterval(1, 8));
            }

            // make each zero two "jump"
            if (keySpace) {
                for (var z2=0; z2<existingZeroTwoObjects.length; z2++) {
                    var zerotwo = sceneElements.sceneGraph.getObjectByName(existingZeroTwoObjects[z2].name).children[0];
                    zerotwo.position.y += 1;
                    if (zerotwo.position.y > 18) {
                        zerotwo.position.y = 13.5;
                    }  
                }
            } else if (!keySpace) {
                for (var z2=0; z2<existingZeroTwoObjects.length; z2++) {
                    var zerotwo = sceneElements.sceneGraph.getObjectByName(existingZeroTwoObjects[z2].name).children[0];
                    zerotwo.position.y = 13.5;
                }
            }

            // ANIMATE TREES

            // Change color of tree when mouse hover
            raycaster.setFromCamera(mouse, sceneElements.camera);
            
            // calculate objects intersecting the picking ray

            for (var t = 1; t < 5; t++) {
                var array = sceneElements.sceneGraph.getObjectByName("tree" + t).children;
                var intersects = raycaster.intersectObjects(array);        

                if (intersects.length > 0 && array.includes(intersects[0].object)) {
                    if (t == 1) {
                        intersects[0].object.material.color.set(0xadff2f);
                    } else if (t == 2) {
                        intersects[0].object.material.color.set(0xfb33db);
                    } else if (t == 3) {
                        intersects[0].object.material.color.set(0xff6600);
                    } else {
                        intersects[0].object.material.color.set(0xe92efb);
                    }
                    
                } else {
                    for (var k = 0; k < array.length; k++) {
                        array[k].material.color.set( 0x00472a);
                    }
                }
            }
            

            // ANIMATE MAZES

            // move cylinder with arrows around the maze (1st person camera)

            var cylinder1 = sceneElements.sceneGraph.getObjectByName("cylinderObject3D1").children[0];
            var cylinder2 = sceneElements.sceneGraph.getObjectByName("cylinderObject3D2").children[0];
            var cylinder3 = sceneElements.sceneGraph.getObjectByName("cylinderObject3D3").children[0];
            var cylinder4 = sceneElements.sceneGraph.getObjectByName("cylinderObject3D4").children[0];

            var camera = sceneElements.camera;
            if (keyTab) { // press Tab to change to the beginning of the maze
                if (cameraFlag) { 
                    camera.position.set(0, 5, 149); // only after the 1st time the user pressed Tab, the camera position changed to this position; after that, the flag becomes false and then the camera position "follows" the cylinder
                    cameraFlag = false;
                }
                if (keyArrowUp && cylinder4.position.z >= 52) { // move forward
                    cylinder4.position.z -= 1;
                    cylinder1.position.z -= 1;
                    cylinder2.position.z -= 1;
                    cylinder3.position.z -= 1;
                    camera.position.z -= 1;
            }
                if (keyArrowDown && cylinder4.position.z <= 145) { // move back
                    cylinder4.position.z += 1;
                    cylinder1.position.z += 1;
                    cylinder2.position.z += 1;
                    cylinder3.position.z += 1;
                    camera.position.z += 1;
                }

                if (keyArrowLeft && cylinder4.position.x >= -48) { // move to the left
                    cylinder4.position.x -= 1;
                    cylinder1.position.x -= 1;
                    cylinder2.position.x -= 1;
                    cylinder3.position.x -= 1;
                    camera.position.x -= 1;
                }

                if (keyArrowRight && cylinder4.position.x <= 48) { // move to the right
                    cylinder4.position.x += 1;
                    cylinder1.position.x += 1;
                    cylinder2.position.x += 1;
                    cylinder3.position.x += 1;
                    camera.position.x += 1;
                }
            }

            // Update camera to the default position (pressing Esc) --> look at the center of the scene
            var camera = sceneElements.camera;
            if (keyEsc) {
                camera.position.set(-30, 40, 50);
                camera.lookAt(new THREE.Vector3(0, 5, 10));
                sceneElements.control.update();
            }

            // ANIMATE LIGHTS

            // Add/remove lights

            if (keyR) { // pressing R
                var redLight = sceneElements.sceneGraph.getObjectByName("hLight2");
                redLight.visible = true;
                var whiteLight = sceneElements.sceneGraph.getObjectByName("hLight1");
                whiteLight.visible = false;
            } else if (keyW) { // pressing W
                var redLight = sceneElements.sceneGraph.getObjectByName("hLight2");
                redLight.visible = false;
                var whiteLight = sceneElements.sceneGraph.getObjectByName("hLight1");
                whiteLight.visible = true;
            } else if (!keyR && !keyW) {
                var redLight = sceneElements.sceneGraph.getObjectByName("hLight2");
                redLight.visible = false;
                var whiteLight = sceneElements.sceneGraph.getObjectByName("hLight1");
                whiteLight.visible = false;
            }
            
            // Rendering
            helper.render(sceneElements);
            sceneElements.control.update();
            requestAnimationFrame(animate);
        }

        // STARTING
        init();
    </script>
</head>
<body>
    <audio id="player" autoplay loop>
        <source src="resources/danceOfTheDruids.mp3" type="audio/mp3">
    </audio>
    <div id="Tag3DScene"> </div>
</body>
</html>