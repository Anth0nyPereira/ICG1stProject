<!DOCTYPE html>

<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title> 3D scene </title>

    <script type="module">

        import * as THREE from "https://threejs.org/build/three.module.js";

        import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";

        import { ConvexGeometry } from "https://threejs.org/examples/jsm/geometries/ConvexGeometry.js";

        // TO INITIALIZE

        const helper = {

            initEmptyScene: function (sceneElements) {

                // ************************** //
                // Create the 3D scene
                // ************************** //
                sceneElements.sceneGraph = new THREE.Scene();


                // ************************** //
                // Add camera
                // ************************** //
                const width = window.innerWidth;
                const height = window.innerHeight;
                const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 500);
                sceneElements.camera = camera;
                

                // position and point the camera to the center of the scene
        camera.position.x = -30;
        camera.position.y = 40;
        camera.position.z = 50;
        camera.lookAt(new THREE.Vector3(0, 5, 10));

                // ************************** //
                // Illumination
                // ************************** //

                // ************************** //
                // Add ambient light
                // ************************** //
                const ambientLight = new THREE.AmbientLight('rgb(255, 255, 255)', 0.2);
                sceneElements.sceneGraph.add(ambientLight);

                // ***************************** //
                // lights
                // ***************************** //
                
        var light = new THREE.DirectionalLight( 0xffffff );
        light.position.set( 0, 1, 1 ).normalize();
        sceneElements.sceneGraph.add(light);
        

        const alight = new THREE.AmbientLight( 0x404040 ); // soft white light
        sceneElements.sceneGraph.add( alight );
        
        var pLight1 = new THREE.PointLight(0xffffbb, 25, 70);
        pLight1.position.set(105, 20, 0);
        sceneElements.sceneGraph.add(pLight1);

        var pLight2 = new THREE.PointLight(0xffffbb, 25, 70);
        pLight2.position.set(-105, 20, 0);
        sceneElements.sceneGraph.add(pLight2);

        var pLight3 = new THREE.PointLight(0xffffbb, 25, 70);
        pLight3.position.set(0, 20, 105);
        sceneElements.sceneGraph.add(pLight3);

        var pLight4 = new THREE.PointLight(0xffffbb, 25, 70);
        pLight4.position.set(0, 20, -105);
        sceneElements.sceneGraph.add(pLight4);
        

        // Hemisphere Light
        //const hLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 5);
        //sceneElements.sceneGraph.add(hLight);

                // *********************************** //
                // Create renderer (with shadow map)
                // *********************************** //
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                sceneElements.renderer = renderer;
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setClearColor('rgb(0,51,102)', 1.0);
                renderer.setSize(width, height);

                // Setup shadowMap property
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;


                // **************************************** //
                // Add the rendered image in the HTML DOM
                // **************************************** //
                const htmlElement = document.querySelector("#Tag3DScene");
                htmlElement.appendChild(renderer.domElement);

                // ************************** //
                // NEW --- Control for the camera
                // ************************** //
                sceneElements.control = new OrbitControls(camera, renderer.domElement);
                sceneElements.control.screenSpacePanning = true;

            },

            render: function render(sceneElements) {
                sceneElements.renderer.render(sceneElements.sceneGraph, sceneElements.camera);
            },
        };

        // BUILDING THE SCENE
        // To store the scene graph, and elements usefull to rendering the scene
        const sceneElements = {
            sceneGraph: null,
            camera: null,
            control: null,  // NEW
            renderer: null,
        };


        // Functions are called
        //  1. Initialize the empty scene
        //  2. Add elements within the scene
        //  3. Animate
        function init() {
            helper.initEmptyScene(sceneElements);
            load3DObjects(sceneElements.sceneGraph);
            requestAnimationFrame(computeFrame);
        }

        // HANDLING EVENTS

        window.addEventListener('resize', resizeWindow);

        //To keep track of the keyboard - WASD
        var keyD = false, keyA = false, keyS = false, keyW = false, keyPlus = false, keyMinus = false, keyP = false, keyM = false, keyArrowUp = false, keyArrowDown = false, keyArrowLeft = false, keyArrowRight = false, keyShift = false, keyEnter = false, keyAlt = false, keyAltGr = false;
        document.addEventListener('keydown', onDocumentKeyDown, false);
        document.addEventListener('keyup', onDocumentKeyUp, false);
        document.addEventListener('mousemove', onDocumentMouseMove, false);

        function onDocumentMouseMove(event)
{
    // the following line would stop any other event handler from firing
    // (such as the mouse's TrackballControls)
    event.preventDefault();

    // update the mouse variable
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

}

        // Update render image size and camera aspect when the window is resized
        function resizeWindow(eventParam) {
            const width = window.innerWidth;
            const height = window.innerHeight;

            sceneElements.camera.aspect = width / height;
            sceneElements.camera.updateProjectionMatrix();

            sceneElements.renderer.setSize(width, height);
        }

        function onDocumentKeyDown(event) {
            switch (event.keyCode) {
                case 68: //d
                    keyD = true;
                    break;
                case 83: //s
                    keyS = true;
                    break;
                case 65: //a
                    keyA = true;
                    break;
                case 87: //w
                    keyW = true;
                    break;
                case 187: //+
                    keyPlus = true;
                    break;
                case 189: //-
                    keyMinus = true;
                    break;
                case 80: //P 
                    keyP = true;
                    break;
                case 77: //M
                    keyM = true;
                    break;
                case 38: // ArrowUp
                    keyArrowUp = true;
                    break;
                case 40: // ArrowDown
                    keyArrowDown = true;
                    break;
                case 37: // ArrowLeft
                    keyArrowLeft = true;
                    break;
                case 39: // ArrowRight
                    keyArrowRight = true;
                    break;
                case 16: // Shift (right one)
                    keyShift = true;
                    break;
                case 13: // Enter
                    keyEnter = true;
                    break;
                case 18: // Alt
                    keyAlt = true;
                    break;
                case 225: // AltGr
                    keyAltGr = true;
                    break;
                }
        }
        function onDocumentKeyUp(event) {
            switch (event.keyCode) {
                case 68: //d
                    keyD = false;
                    break;
                case 83: //s
                    keyS = false;
                    break;
                case 65: //a
                    keyA = false;
                    break;
                case 87: //w
                    keyW = false;
                    break;
                case 187: //+
                    keyPlus = false;
                    break;
                case 189: //-
                    keyMinus = false;
                    break;
                case 80: //P 
                    keyP = false;
                    break;
                case 77: //M
                    keyM = false;
                    break;
                case 38: // ArrowUp
                    keyArrowUp = false;
                    break;
                case 40: // ArrowDown
                    keyArrowDown = false;
                    break;
                case 37: // ArrowLeft
                    keyArrowLeft = false;
                    break;
                case 39: // ArrowRight
                    keyArrowRight = false;
                    break;
                case 16: // Shift (right one)
                    keyShift = false;
                    break;
                case 13: // Enter
                    keyEnter = false;
                    break;
                case 18: // Alt
                    keyAlt = false;
                    break;
                case 225: // AltGr
                    keyAltGr = false;
                    break;
            }
    }
function makeCircle(color) {
    var radius =  1.0;  
    var tubeRadius =  5.0;  
    var radialSegments = 30;  
    var tubularSegments = 100;  
    var geometry = new THREE.TorusGeometry(radius, tubeRadius,radialSegments, tubularSegments);
    var material = new THREE.MeshBasicMaterial({color: color});
    var mesh = new THREE.Mesh(geometry, material);
    //mesh.scale.set(0.1, 0.1, 0.1);
    return mesh;
}

function makeSemiSphere() {
    const midSphereRadius =  5.8;  
    const widthSegments = 30;  
    const heightSegments = 30;  
    const phiStart = Math.PI * 0.68;  
    const phiLength = Math.PI * 1.06;  
    const thetaStart = Math.PI * 1.00;  
    const thetaLength = Math.PI * 0.46; 

    var midSphereGeometry = new THREE.SphereGeometry(
        midSphereRadius,
        widthSegments, heightSegments,
        phiStart, phiLength,
        thetaStart, thetaLength);
    
    var material = new THREE.MeshBasicMaterial({color: 0xffc0cb});
    var mesh = new THREE.Mesh(midSphereGeometry, material);
    return mesh;
    
}

function makeHair() {
    var hair = new THREE.Group();
    var geometry = new THREE.BoxGeometry( 0.5, 20, 8);
    var material = new THREE.MeshBasicMaterial( {color: 0xffc0cb} );
    var hair1 = new THREE.Mesh( geometry, material );

    var shape = new THREE.Shape();
    shape.moveTo(5,0);
    shape.lineTo(0, 10);
    shape.lineTo(-5, 0);
    shape.lineTo(5, 0);

    const extrudeSettings = {
        steps: 2,
        depth: 0.01,
        bevelEnabled: true,
        bevelThickness: 1,
        bevelSize: 1,
        bevelOffset: 0,
        bevelSegments: 1
};

var shapeGeometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
var shapeMaterial = new THREE.MeshBasicMaterial( { color: 0xffc0cb } );
var shapeHair = new THREE.Mesh( shapeGeometry, shapeMaterial ) ;
shapeHair.rotation.y = Math.PI/2;
shapeHair.scale.set(1, 1.8, 1.3);
shapeHair.position.y = -10;

hair.add(hair1);
hair.add(shapeHair);


    return hair;
}

function createHead() {
    var head = new THREE.Group();
    var circle = makeCircle(0xf7e7ce);
    var beginHair = makeCircle(0xffc0cb);
    beginHair.scale.set(0.9, 0.2, 1);
    beginHair.position.set(0, 5, -1);
    beginHair.rotation.x = -0.2;
    /*
    var beginHair = makeSemiSphere();
    beginHair.rotation.z = 3*Math.PI/2 + 0.2;
    beginHair.position.y = 10;
    beginHair.position.z = -4;
    */
    var hair = makeHair();
    hair.rotation.y = Math.PI/2;
    hair.position.z = -4.8;
    hair.position.y = -6;

    // eyebrows
    var eyeBrowsShape = new THREE.Shape();
    eyeBrowsShape.moveTo( 0,0 );
    eyeBrowsShape.lineTo(0.5, 1);
    eyeBrowsShape.lineTo(1.5, 3);
    eyeBrowsShape.lineTo(3.5, 3);
    eyeBrowsShape.lineTo(5, 1);
    eyeBrowsShape.lineTo(5.5, 0);
    eyeBrowsShape.lineTo(3.5, 3);
    eyeBrowsShape.lineTo(1.5, 3);
    eyeBrowsShape.lineTo(0, 0);

    var extrudeSettings = {
        steps: 2,
        depth: 0.01,
        bevelEnabled: true,
        bevelThickness: 1,
        bevelSize: 1,
        bevelOffset: 0,
        bevelSegments: 1
    };

    var eyeBrowsGeometry = new THREE.ExtrudeGeometry( eyeBrowsShape, extrudeSettings );
    var eyeBrowsMaterial = new THREE.MeshBasicMaterial( { color: 0x000000 } );
    var eyeBrow1 = new THREE.Mesh( eyeBrowsGeometry, eyeBrowsMaterial ) ;
    eyeBrow1.position.set(-4, 2.5, 4);
    eyeBrow1.rotation.y = -0.2;
    eyeBrow1.scale.set(0.3, 0.3, 0.3);

    var eyeBrow2 = new THREE.Mesh( eyeBrowsGeometry, eyeBrowsMaterial ) ;
    eyeBrow2.position.set(3, 2.5, 4);
    eyeBrow2.rotation.y = 0.2;
    eyeBrow2.scale.set(0.3, 0.3, 0.3);

    // mouth
    var mouthShape = new THREE.Shape();
    mouthShape.moveTo(-1, 0);
    mouthShape.lineTo(1, 0);
    mouthShape.bezierCurveTo(0.2, -0.1, -0.2, -0.1, -1, 0);

    var mouthGeometry = new THREE.ExtrudeGeometry( mouthShape, extrudeSettings );
    var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
    var mouthMaterial = new THREE.MeshBasicMaterial({color: randomColor})
    var mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
    mouth.scale.set(0.5, 2, 0.5);
    mouth.position.set(0, 0, 5);

    // band
    var bandGeometry = new THREE.BoxGeometry(8, 0.5, 1);
    var bandMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
    var band1 = new THREE.Mesh(bandGeometry, bandMaterial);
    band1.position.y = 6.2;

    // horns
    var hornRadius =  1.0;  
    var hornHeight = 10.0;  
    var hornRadialSegments =  3;  
    var hornGeometry = new THREE.ConeGeometry(hornRadius, hornHeight, hornRadialSegments);
    var hornMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
    var horn1 = new THREE.Mesh(hornGeometry, hornMaterial);
    horn1.scale.set(1, 0.5, 1);
    horn1.position.set(2, 7, 0);

    var horn2 = new THREE.Mesh(hornGeometry, hornMaterial);
    horn2.scale.set(1, 0.5, 1);
    horn2.position.set(-2, 7, 0);

    head.add(horn2);
    head.add(horn1);
    head.add(band1);
    head.add(mouth);
    head.add(eyeBrow1);
    head.add(eyeBrow2);
    head.add(circle);
    head.add(beginHair);
    head.add(hair);
    return head;
}

function createBody() {
    var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
    var body = new THREE.Group();

    // torse
    var geometry = new THREE.BoxGeometry( 8, 4, 4);
    var material = new THREE.MeshBasicMaterial( {color: 0xff0000} );
    var torse = new THREE.Mesh( geometry, material );
    torse.rotation.z = Math.PI/2;
    torse.scale.set(2,2,2);
    body.add(torse);

    // dress
    var points = [];
    for (var i = 0; i < 10; i++) {
    points.push(new THREE.Vector2(Math.cos(i * 0.2) * 3 + 3, (i - 5) * 0.8));
    }
    var latheGeometry = new THREE.LatheGeometry(points);
    var dress = new THREE.Mesh( latheGeometry, material );
    dress.scale.set(1.5, 3.5, 1.5);
    dress.position.y = -10;
    body.add(dress);

    // 1st forearm
    var forearmGeometry = new THREE.CylinderGeometry( 2, 2, 20, 50 );
    var forearm1 = new THREE.Mesh( forearmGeometry, material );
    forearm1.scale.set(1, 0.7, 1);
    forearm1.position.set(16, 13, 0);
    forearm1.rotation.z = -0.6;
    body.add(forearm1);

    // 2nd forearm
    var forearm2 = new THREE.Mesh( forearmGeometry, material );
    forearm2.scale.set(1, 0.7, 1);
    forearm2.position.set(-16, 13, 0);
    forearm2.rotation.z = 0.6;
    body.add(forearm2);

    // 1st arm
    var arm1 = new THREE.Mesh( forearmGeometry, material );
    arm1.scale.set(1, 0.3, 1);
    arm1.rotation.z = Math.PI/2;
    arm1.position.set(7, 6, 0);
    body.add(arm1);

    // 2nd arm
    var arm2 = new THREE.Mesh( forearmGeometry, material );
    arm2.scale.set(1, 0.3, 1);
    arm2.rotation.z = Math.PI/2;
    arm2.position.set(-7, 6, 0);
    body.add(arm2);

    // 1st sphere arm
    var sphereGeometry = new THREE.SphereGeometry( 2, 32, 32 );
    var sphereMaterial = new THREE.MeshBasicMaterial( {color: 0x808080} );
    var sphere1 = new THREE.Mesh( sphereGeometry, sphereMaterial );
    sphere1.position.set(11, 6, 0);
    body.add(sphere1);

    // 2nd sphere arm
    var sphere2 = new THREE.Mesh( sphereGeometry, sphereMaterial );
    sphere2.position.set(-11, 6, 0);
    body.add(sphere2);

    // 1st leg
    var legGeometry = new THREE.CylinderGeometry( 1, 2, 30, 32 );
    var legMaterial = new THREE.MeshBasicMaterial( {color: 0x000000} );
    var leg1 = new THREE.Mesh( legGeometry, legMaterial );
    leg1.position.set(-4, -30, 0);
    body.add(leg1);

    // 2nd leg
    var leg2 = new THREE.Mesh( legGeometry, legMaterial );
    leg2.position.set(4, -30, 0);
    body.add(leg2);

    // 1st boot
    var whiteMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
    var bootPoints = [];
    for ( var i = 0; i < 5; i ++ ) {
	    bootPoints.push(new THREE.Vector2( 2, i));
    }
    var bootGeometry = new THREE.LatheGeometry(bootPoints);
    var boot1 = new THREE.Mesh(bootGeometry, whiteMaterial);
    boot1.position.set(4, -45, 0);
    body.add(boot1);

    // 2nd boot
    var boot2 = new THREE.Mesh(bootGeometry, whiteMaterial);
    boot2.position.set(-4, -45, 0);
    body.add(boot2);

    // 1st foot
    var shape = new THREE.Shape();
    shape.moveTo(-1, 0);
    //shape.lineTo(3, 0);
    shape.bezierCurveTo(-0.5, 0.25, 0.5, 0.25, 1, 0);
    shape.lineTo(-1, 0);

    var extrudeSettings = {
        steps: 20,
        depth: 3,
        bevelEnabled: true,
        bevelThickness: 1,
        bevelSize: 1,
        bevelOffset: 0,
        bevelSegments: 1
    }

    var footGeometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
    var wireframeMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
    var foot1 = new THREE.Mesh(footGeometry, wireframeMaterial);
    foot1.scale.set(1, 2, 1.8);
    foot1.position.set(4, -47, -1);
    body.add(foot1);

    // 2nd foot
    var foot2 = new THREE.Mesh(footGeometry, wireframeMaterial);
    foot2.scale.set(1, 2, 1.8);
    foot2.position.set(-4, -47, -1);
    body.add(foot2);

    // HANDS

    // 1st wrist
    var skinMaterial = new THREE.MeshBasicMaterial({color: 0xf7e7ce});
    var wrist1 = new THREE.Mesh( forearmGeometry, skinMaterial );
    wrist1.scale.set(0.7, 0.2, 0.7);
    wrist1.position.set(21, 20, 0);
    wrist1.rotation.z = -0.6;
    body.add(wrist1);

    // 1st palm
    var palmRadius = 1.5;  
    var palmTubeRadius = 1.5;  
    var palmRadialSegments = 8;  
    var palmTubularSegments = 24;  
    var palmGeometry = new THREE.TorusGeometry(palmRadius, palmTubeRadius, palmRadialSegments, palmTubularSegments);
    var palm1 = new THREE.Mesh(palmGeometry, skinMaterial);
    palm1.position.set(23, 22, 0);
    palm1.rotation.x = Math.PI/2;
    body.add(palm1);

    // 2nd wrist
    var wrist2 = new THREE.Mesh( forearmGeometry, skinMaterial );
    wrist2.scale.set(0.7, 0.2, 0.7);
    wrist2.position.set(-21, 20, 0);
    wrist2.rotation.z = 0.6;
    body.add(wrist2);

    // 2nd palm
    var palm2 = new THREE.Mesh(palmGeometry, skinMaterial);
    palm2.position.set(-23, 22, 0);
    palm2.rotation.x = Math.PI/2;
    body.add(palm2);

    // Flashlight
    var flashlight1 = createLathe(0xffcc00);
    flashlight1.scale.set(0.4, 0.4, 0.4);
    flashlight1.position.set(23, 26, 0);
    body.add(flashlight1);

    var pointLight = new THREE.PointLight(0xffff00, 2, 22);
    pointLight.position.set(23, 26, 0);
    body.add(pointLight);

    // Holder
    var holderRadiusTop =  1.3;  
    var holderRadiusBottom =  0.7;  
    var holderHeight = 12;  
    var holderRadialSegments = 12;  
    var holderGeometry = new THREE.CylinderGeometry(holderRadiusTop, holderRadiusBottom, holderHeight, holderRadialSegments);
    var holderMaterial = new THREE.MeshBasicMaterial({color: 0x312113});
    var holder1 = new THREE.Mesh(holderGeometry, holderMaterial);
    holder1.position.set(23, 20, 0);
    body.add(holder1);

    // Neck
    var neck1 = new THREE.Mesh( forearmGeometry, skinMaterial );
    neck1.position.set(0, 5, 0);
    body.add(neck1);

    // Arrows (dress)
    var arrowShape = new THREE.Shape();
    arrowShape.moveTo(1, 0);
    arrowShape.lineTo(2, 0);
    arrowShape.lineTo(1.5, 1.5);
    arrowShape.lineTo(2, 3);
    arrowShape.lineTo(1, 3);
    arrowShape.lineTo(0.5, 1.5);
    arrowShape.lineTo(1, 0);

    var ArrowExtrudeSettings = {
        steps: 2,
        depth: 0.5,
        bevelEnabled: false,
        bevelThickness: 1,
        bevelSize: 1,
        bevelOffset: 0,
        bevelSegments: 1
    };

    var arrowGeometry = new THREE.ExtrudeGeometry( arrowShape, ArrowExtrudeSettings);
    var arrowMaterial = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
    var arrow1 = new THREE.Mesh( arrowGeometry, arrowMaterial );
    arrow1.scale.set(1, 0.5, 1);
    arrow1.position.set(1, -1, 3.7);

    var arrowEdges = new THREE.EdgesGeometry(arrowGeometry);
    var arrowLine1 = new THREE.LineSegments( arrowEdges, new THREE.LineBasicMaterial( { color: 0x000000 } ) );
    arrowLine1.scale.set(1, 0.5, 1);
    arrowLine1.position.set(1, -1, 3.7);

    body.add(arrow1);
    body.add(arrowLine1);

    var arrow2 = new THREE.Mesh( arrowGeometry, arrowMaterial );
    arrow2.scale.set(1, 0.5, 1);
    arrow2.position.set(-1, -1, 4.2);
    arrow2.rotation.y = Math.PI;
    var arrowLine2 = new THREE.LineSegments( arrowEdges, new THREE.LineBasicMaterial( { color: 0x000000 } ) );
    arrowLine2.scale.set(1, 0.5, 1);
    arrowLine2.position.set(-1, -1, 4.2);
    arrowLine2.rotation.y = Math.PI;

    body.add(arrow2);
    body.add(arrowLine2);

    var arrowMaterial2 = new THREE.MeshBasicMaterial({color: 0xb8860b});
    var arrow3 = new THREE.Mesh( arrowGeometry, arrowMaterial2 );
    arrow3.scale.set(0.8, 0.4, 1);
    arrow3.position.set(0, -1, 3.7);
    var arrowLine3 = new THREE.LineSegments( arrowEdges, new THREE.LineBasicMaterial( { color: 0x000000 } ) );
    arrowLine3.scale.set(0.8, 0.4, 1);
    arrowLine3.position.set(0, -1, 3.7);

    var arrow4 = new THREE.Mesh( arrowGeometry, arrowMaterial2 );
    arrow4.scale.set(0.8, 0.4, 1);
    arrow4.rotation.y = Math.PI;
    arrow4.position.set(0, -1, 4.2);
    var arrowLine4 = new THREE.LineSegments( arrowEdges, new THREE.LineBasicMaterial( { color: 0x000000 } ) );
    arrowLine4.scale.set(0.8, 0.4, 1);
    arrowLine4.rotation.y = Math.PI;
    arrowLine4.position.set(0, -1, 4.2);

    body.add(arrow3);
    body.add(arrow4);
    body.add(arrowLine3);
    body.add(arrowLine4);

    // belt

    var beltPoints = [];
    for (let i = 4; i < 6; ++i) {
        beltPoints.push(new THREE.Vector2(7, i));
    }
    var beltGeometry = new THREE.LatheGeometry(beltPoints);
    var beltMaterial = new THREE.MeshBasicMaterial({color: 0x654321});
    var belt1 = new THREE.Mesh(beltGeometry, beltMaterial);
    belt1.scale.set(0.85, 0.85, 0.6);
    belt1.position.set(0, -4.3, -0.7);
    body.add(belt1);

    // collar
    var collarGeometry = new THREE.BoxGeometry(5, 5, 5);
    var collarMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
    var collar1 = new THREE.Mesh(collarGeometry, collarMaterial);
    body.add(collar1);
    collar1.position.set(0, 10, 0);

    // tie
    var tieShape = new THREE.Shape();
    tieShape.moveTo(2, 2);
    tieShape.lineTo(3, 1);
    tieShape.lineTo(4, 2);
    tieShape.lineTo(3, 5);
    tieShape.lineTo(3.5, 5.5);
    tieShape.lineTo(3, 6);
    tieShape.lineTo(2.5, 5.5);
    tieShape.lineTo(3, 5);
    tieShape.lineTo(2, 2);
    

    var tieSettings = {
        steps: 2,
        depth: 0.5,
        bevelEnabled: false,
        bevelThickness: 1,
        bevelSize: 1,
        bevelOffset: 0,
        bevelSegments: 1
    };

    var tieGeometry = new THREE.ExtrudeGeometry(tieShape, tieSettings);
    var tieMaterial = new THREE.MeshBasicMaterial({color: 0xffa500});
    var tie1 = new THREE.Mesh(tieGeometry, tieMaterial);
    tie1.scale.set(0.9, 0.9, 0.9);
    tie1.position.set(-2.75, 7.1, 2.5);

    body.add(tie1);

    // COMPLETE LEAF
    
    var completeLeaf1 = createComplexLeaf(0x006400, 0x149414);
    completeLeaf1.position.set(0, 0, 0);
    completeLeaf1.scale.set(0.7, 0.7, 0.7);
    completeLeaf1.rotateOnWorldAxis(new THREE.Vector3(0,0,1), -0.9);
    completeLeaf1.position.set(9, 12.5, 0);
    // completeLeaf1.rotation.z = -0.3;
    
    var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
    var completeLeaf2 = createComplexLeaf(randomColor, randomColor);
    completeLeaf2.translateZ(-100).translateY(-10);
    completeLeaf2.rotation.z = -0.6;
    completeLeaf2.rotation.y = Math.PI/2;

    body.add(completeLeaf2);
    body.add(completeLeaf1);

    return body;
}

function createComplexLeaf(color1, color2) {

    var completeLeaf1 = new THREE.Group();

    // stem

    var stemGeometry = new THREE.CylinderGeometry(0.2, 0.2, 10, 50);
    var stemMaterial = new THREE.MeshBasicMaterial( {color: color1} );
    var stem1 = new THREE.Mesh(stemGeometry, stemMaterial);

    stem1.position.y = 30;
    completeLeaf1.add(stem1);

    // leaves
    var leafShape = new THREE.Shape();
    leafShape.moveTo(0, 0);
    leafShape.bezierCurveTo(1, 2, 1, 3, 0, 4);
    leafShape.bezierCurveTo(-1, 3, -1, 2, 0, 0);

    var leafSettings = {
        steps: 2,
        depth: 0.5,
        bevelEnabled: false,
        bevelThickness: 1,
        bevelSize: 1,
        bevelOffset: 0,
        bevelSegments: 1
    };

    var leafGeometry = new THREE.ExtrudeGeometry(leafShape, leafSettings);
    var leafMaterial = new THREE.MeshBasicMaterial({color: color2});
    var leaf1 = new THREE.Mesh(leafGeometry, leafMaterial);
    leaf1.scale.set(1, 2, 1);
    leaf1.position.y = 34;

    // right side

    var leaf2 = new THREE.Mesh(leafGeometry, leafMaterial);
    leaf2.scale.set(1, 1.5, 1);
    leaf2.position.set(0, 34, 0);
    leaf2.rotation.z = -0.6;

    var leaf3 = new THREE.Mesh(leafGeometry, leafMaterial);
    leaf3.scale.set(1, 1.5, 1);
    leaf3.position.set(0, 32, 0);
    leaf3.rotation.z = -0.8;

    var leaf4 = new THREE.Mesh(leafGeometry, leafMaterial);
    leaf4.scale.set(1, 1.5, 1);
    leaf4.position.set(0, 29.5, 0);
    leaf4.rotation.z = -0.8;

    // left side

    var leaf5 = new THREE.Mesh(leafGeometry, leafMaterial);
    leaf5.scale.set(1, 1.5, 1);
    leaf5.position.set(0, 34, 0);
    leaf5.rotation.y = Math.PI;
    leaf5.rotation.z = -0.6;

    var leaf6 = new THREE.Mesh(leafGeometry, leafMaterial);
    leaf6.scale.set(1, 1.5, 1);
    leaf6.position.set(0, 32, 0);
    leaf6.rotation.y = Math.PI;
    leaf6.rotation.z = -0.8;

    var leaf7 = new THREE.Mesh(leafGeometry, leafMaterial);
    leaf7.scale.set(1, 1.5, 1);
    leaf7.position.set(0, 29.5, 0);
    leaf7.rotation.y = Math.PI;
    leaf7.rotation.z = -0.8;

    completeLeaf1.add(leaf7);
    completeLeaf1.add(leaf6);
    completeLeaf1.add(leaf5);
    completeLeaf1.add(leaf4);
    completeLeaf1.add(leaf3);
    completeLeaf1.add(leaf2);
    completeLeaf1.add(leaf1);

    // BEAUTIFUL EFFECT TBH completeLeaf1.translateX(-80);
    completeLeaf1.rotation.y = Math.PI/2;
    return completeLeaf1;
}

function createZeroTwo() {
    var zerotwo1 = new THREE.Group();
    var head1 = createHead();
    head1.position.x = 0;

    var body1 = createBody();
    body1.position.x = 0;
    body1.position.y = -20;
    
    zerotwo1.add(head1);
    zerotwo1.add(body1);
    return zerotwo1;
}

function createLathe(color) {
    const points = [];
    for (var i = 0; i < 5; i+=0.5) {
        points.push(new THREE.Vector3(i + 4, 0.5*i*i, 0));
    }

    for (var i = 11.125; i < 16; i++ ) {
        points.push(new THREE.Vector3(8.5, i + 0.1*i, 0));
    }

    
    points.push(new THREE.Vector3(8, 18.25, 0));
    points.push(new THREE.Vector3(7.5, 20.125, 0));
    points.push(new THREE.Vector3(7, 21.75, 0));
    points.push(new THREE.Vector3(6.5, 23.125, 0));
    points.push(new THREE.Vector3(6, 24.25, 0));
    points.push(new THREE.Vector3(5.5, 25.125, 0));
    points.push(new THREE.Vector3(5, 25.75, 0));
    points.push(new THREE.Vector3(4.5, 26.125, 0));
    points.push(new THREE.Vector3(4, 26.25, 0));

    const segments = 50;  
    const phiStart = Math.PI * 2.00;  
    const phiLength = Math.PI * 2.00;  
    const geometry = new THREE.LatheGeometry(points, segments, phiStart, phiLength);
    var material = new THREE.MeshBasicMaterial( { color: color, wireframe: true} );
    const lathe = new THREE.Mesh( geometry, material );
    return lathe;

}

function createEdges(geometry) {
    const edges = new THREE.EdgesGeometry( geometry );
    const line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0x000000 } ) );
    return line;
}

function createPiece(color) {
    const shape = new THREE.Shape();
    const x = -0.5;
    const y = 0;
    shape.moveTo(-0.5, 0);
    shape.lineTo(0, 1);
    shape.lineTo(0.5, 0);
    shape.bezierCurveTo(0.2, -0.1, -0.2, -0.1, -0.5, 0);
    
    const extrudeSettings = {
        steps: 2,  
        depth: 0.05,  
        bevelEnabled: true,  
        bevelThickness: 0.1,  
        bevelSize: 0.1,  
        bevelSegments: 0,  
    };

    var geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    var material = new THREE.MeshBasicMaterial( {color: color} );
    var mesh = new THREE.Mesh( geometry, material);
    return mesh;
}

function loadFont(url) {
    const loader = new THREE.FontLoader();
    return new Promise((resolve, reject) => {
    loader.load(url, resolve, undefined, reject);
    });
}

async function doit() {
    const font = await loadFont('https://threejsfundamentals.org/threejs/resources/threejs/fonts/helvetiker_regular.typeface.json');  
    const geometry = new THREE.TextGeometry('three.js', {
    font: font,
    size: 3.0,
    height: .2,
    curveSegments: 12,
    bevelEnabled: true,
    bevelThickness: 0.15,
    bevelSize: .3,
    bevelSegments: 5,
    });
    const mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({color: 0x00ff00}));
    geometry.computeBoundingBox();
    geometry.boundingBox.getCenter(mesh.position).multiplyScalar(-1);
    sceneElements.sceneGraph.add(mesh);
}

function createText() {
    
var loader = new THREE.FontLoader();

loader.load( 'fonts/helvetiker_regular.typeface.js', function ( font ) {

var material = new THREE.MeshPhongMaterial( { color: 0x0033ff, specular: 0x555555, shininess: 30 } );

var geometry = new THREE.TextGeometry( 'Hello three.js!', {
    font: font,
    size: 20000000000,
    height: 5,
    curveSegments: 12,
    bevelEnabled: true,
    bevelThickness: 10,
    bevelSize: 8,
    bevelSegments: 5
} );

var mesh = new THREE.Mesh( geometry, material );

sceneElements.sceneGraph.add(mesh);

var light = new THREE.DirectionalLight( 0xffffff );
light.position.set( 0, 1, 1 ).normalize();
sceneElements.sceneGraph.add(light);


var renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );

renderer.render(  sceneElements.sceneGraph, sceneElements.camera );

} );
}
        function generatePoints() {    
        var points = [];
        for (var i = 0; i < 25; i++) {
        var randomX = Math.round(Math.random() * 4);
        var randomY = Math.round(Math.random() * 25);
        var randomZ = Math.round(Math.random() * 4);
        
        points.push(new THREE.Vector3(randomX, randomY, randomZ));
    }
    return points;
}

function goodPointsArray(array) {
    var count = 0;
    for (var i = 0; i < array.length; i++) {
    var point = array[i];
    if (point.y == 0) {
        count = count + 1;
    }
    }
    if (count >= 3) {
    return true;
    } else {
    return false;
    }
}

function makeStone() {

    var points = generatePoints();

    var bool = goodPointsArray(points);
    while (!bool) {
    points = generatePoints();
    bool = goodPointsArray(points);
    }

    var material2 = new THREE.MeshLambertMaterial({
                color: "rgb(128,128,128)",
                transparent: true
            });
    const meshGeometry = new ConvexGeometry(points);

    const stone = new THREE.Mesh(meshGeometry, material2);
    return stone;
}

function createMaze() {
    var maze = new THREE.Group();
    var planeGeometry = new THREE.PlaneGeometry( 100, 100, 32 );
    var planeMaterial = new THREE.MeshBasicMaterial( {color: 0x567d46, side: THREE.DoubleSide} );
    var plane1 = new THREE.Mesh(planeGeometry, planeMaterial);
    plane1.position.set(0, -0.1, 100);
    plane1.rotation.x = Math.PI/2;


    var boxGeometry = new THREE.BoxGeometry( 10, 10, 10);
    
    
    var usedXValues = [];
    var usedZValues = [];

    var xPossibleValues1stRow = [-45, -35, -25, -15, 15, 25, 35, 45];

    // 1st row of the maze
    var count = 0;
    while (count < 8) {
        var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
        var boxMaterial = new THREE.MeshPhongMaterial( {color: 0x0B5345} );

        var itemX = xPossibleValues1stRow[Math.floor(Math.random() * xPossibleValues1stRow.length)];
        var box = new THREE.Mesh(boxGeometry, boxMaterial);
        var edges = new THREE.EdgesGeometry(boxGeometry);
        var line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color: 0xFFD700}));
        box.position.set(itemX, 5, 55);
        line.position.set(itemX, 5, 55);
        for( var i = 0; i < xPossibleValues1stRow.length; i++){ 
            if ( xPossibleValues1stRow[i] === itemX) { 
                xPossibleValues1stRow.splice(i, 1); 
                i--; 
            }
        }
        maze.add(box);
        maze.add(line);
        count = count + 1;
    }

    var xPossibleValues2ndRow = [-45, -35, -25, -15, 15, 25, 35, 45];
    var possibleNumberBoxes = [4, 5, 6, 7, 8];
    var numberBoxes = possibleNumberBoxes[Math.floor(Math.random() * possibleNumberBoxes.length)];
    // 2nd row
    for (var k=0; k < numberBoxes; k++) {
        var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
        var boxMaterial = new THREE.MeshBasicMaterial( {color: 0x0B5345} );
        var itemX = xPossibleValues2ndRow[Math.floor(Math.random() * xPossibleValues2ndRow.length)];
        var box = new THREE.Mesh(boxGeometry, boxMaterial);
        var edges = new THREE.EdgesGeometry(boxGeometry);
        var line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color: 0xFFD700}));
        box.position.set(itemX, 5, 65);
        line.position.set(itemX, 5, 65);
        for( var i = 0; i < xPossibleValues2ndRow.length; i++){ 
            if ( xPossibleValues2ndRow[i] === itemX) { 
                xPossibleValues2ndRow.splice(i, 1); 
                i--; 
            }
        }
        maze.add(box);
        maze.add(line);
    }

    var xPossibleValues3rdRow = [-45, -35, -25, 25, 35, 45];
    // 3rd row
    var possibleNumberBoxes = [4, 5, 6, 7, 8];
    var numberBoxes = possibleNumberBoxes[Math.floor(Math.random() * possibleNumberBoxes.length)];
    for (var k=0; k < numberBoxes; k++) {
        var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
        var boxMaterial = new THREE.MeshPhongMaterial( {color: 0x0B5345} );
        var itemX = xPossibleValues3rdRow[Math.floor(Math.random() * xPossibleValues3rdRow.length)];
        var box = new THREE.Mesh(boxGeometry, boxMaterial);
        var edges = new THREE.EdgesGeometry(boxGeometry);
        var line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color: 0xFFD700}));
        box.position.set(itemX, 5, 75);
        line.position.set(itemX, 5, 75);
        for( var i = 0; i < xPossibleValues3rdRow.length; i++){ 
            if ( xPossibleValues3rdRow[i] === itemX) { 
                xPossibleValues3rdRow.splice(i, 1); 
                i--; 
            }
        }
        maze.add(box);
        maze.add(line);
    }

    var xPossibleValues4thRow = [-45, -35, -25, -5, 5, 25, 35, 45];
    // 4th row
    var possibleNumberBoxes = [4, 5, 6, 7, 8];
    var numberBoxes = possibleNumberBoxes[Math.floor(Math.random() * possibleNumberBoxes.length)];
    for (var k=0; k < numberBoxes; k++) {
        var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
        var boxMaterial = new THREE.MeshBasicMaterial( {color: 0x0B5345} );
        var itemX = xPossibleValues4thRow[Math.floor(Math.random() * xPossibleValues4thRow.length)];
        var box = new THREE.Mesh(boxGeometry, boxMaterial);
        var edges = new THREE.EdgesGeometry(boxGeometry);
        var line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color: 0xFFD700}));
        box.position.set(itemX, 5, 85);
        line.position.set(itemX, 5, 85);
        for( var i = 0; i < xPossibleValues4thRow.length; i++){ 
            if ( xPossibleValues4thRow[i] === itemX) { 
                xPossibleValues4thRow.splice(i, 1); 
                i--; 
            }
        }
        maze.add(box);
        maze.add(line);
    }

    var xPossibleValues5thRow = [-45, -5, 5, 45];
    // 5th row
    var possibleNumberBoxes = [4, 5, 6, 7, 8];
    var numberBoxes = possibleNumberBoxes[Math.floor(Math.random() * possibleNumberBoxes.length)];
    for (var k=0; k < numberBoxes; k++) {
        var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
        var boxMaterial = new THREE.MeshPhongMaterial( {color: 0x0B5345} );
        var itemX = xPossibleValues5thRow[Math.floor(Math.random() * xPossibleValues5thRow.length)];
        var box = new THREE.Mesh(boxGeometry, boxMaterial);
        var edges = new THREE.EdgesGeometry(boxGeometry);
        var line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color: 0xFFD700}));
        box.position.set(itemX, 5, 95);
        line.position.set(itemX, 5, 95);
        for( var i = 0; i < xPossibleValues5thRow.length; i++){ 
            if ( xPossibleValues5thRow[i] === itemX) { 
                xPossibleValues5thRow.splice(i, 1); 
                i--; 
            }
        }
        maze.add(box);
        maze.add(line);
    }

    var xPossibleValues6thRow = [-45, -25, -15, -5, 5, 15, 25, 45];
    // 6th row
    var possibleNumberBoxes = [4, 5, 6, 7, 8];
    var numberBoxes = possibleNumberBoxes[Math.floor(Math.random() * possibleNumberBoxes.length)];
    for (var k=0; k < numberBoxes; k++) {
        var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
        var boxMaterial = new THREE.MeshBasicMaterial( {color: 0x0B5345} );
        var itemX = xPossibleValues6thRow[Math.floor(Math.random() * xPossibleValues6thRow.length)];
        var box = new THREE.Mesh(boxGeometry, boxMaterial);
        var edges = new THREE.EdgesGeometry(boxGeometry);
        var line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color: 0xFFD700}));
        box.position.set(itemX, 5, 105);
        line.position.set(itemX, 5, 105);
        for( var i = 0; i < xPossibleValues6thRow.length; i++){ 
            if ( xPossibleValues6thRow[i] === itemX) { 
                xPossibleValues6thRow.splice(i, 1); 
                i--; 
            }
        }
        maze.add(box);
        maze.add(line);
    }

    var xPossibleValues7thRow = [-45, -5, 5, 45];
    // 7th row
    var possibleNumberBoxes = [4, 5, 6, 7, 8];
    var numberBoxes = possibleNumberBoxes[Math.floor(Math.random() * possibleNumberBoxes.length)];
    for (var k=0; k < numberBoxes; k++) {
        var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
        var boxMaterial = new THREE.MeshPhongMaterial( {color: 0x0B5345} );
        var itemX = xPossibleValues7thRow[Math.floor(Math.random() * xPossibleValues7thRow.length)];
        var box = new THREE.Mesh(boxGeometry, boxMaterial);
        var edges = new THREE.EdgesGeometry(boxGeometry);
        var line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color: 0xFFD700}));
        box.position.set(itemX, 5, 115);
        line.position.set(itemX, 5, 115);
        for( var i = 0; i < xPossibleValues7thRow.length; i++){ 
            if ( xPossibleValues7thRow[i] === itemX) { 
                xPossibleValues7thRow.splice(i, 1); 
                i--; 
            }
        }
        maze.add(box);
        maze.add(line);
    }

    var xPossibleValues8thRow = [-45, -35, -25, -5, 5, 25, 35, 45];
    // 8th row
    var possibleNumberBoxes = [4, 5, 6, 7, 8];
    var numberBoxes = possibleNumberBoxes[Math.floor(Math.random() * possibleNumberBoxes.length)];
    for (var k=0; k < numberBoxes; k++) {
        var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
        var boxMaterial = new THREE.MeshBasicMaterial( {color: 0x0B5345} );
        var itemX = xPossibleValues8thRow[Math.floor(Math.random() * xPossibleValues8thRow.length)];
        var box = new THREE.Mesh(boxGeometry, boxMaterial);
        var edges = new THREE.EdgesGeometry(boxGeometry);
        var line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color: 0xFFD700}));
        box.position.set(itemX, 5, 125);
        line.position.set(itemX, 5, 125);
        for( var i = 0; i < xPossibleValues8thRow.length; i++){ 
            if ( xPossibleValues8thRow[i] === itemX) { 
                xPossibleValues8thRow.splice(i, 1); 
                i--; 
            }
        }
        maze.add(box);
        maze.add(line);
    }

    var xPossibleValues9thRow = [-45, -35, -25, 25, 35, 45];
    // 9th row
    var possibleNumberBoxes = [4, 5, 6, 7, 8];
    var numberBoxes = possibleNumberBoxes[Math.floor(Math.random() * possibleNumberBoxes.length)];
    for (var k=0; k < numberBoxes; k++) {
        var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
        var boxMaterial = new THREE.MeshPhongMaterial( {color: 0x0B5345} );
        var itemX = xPossibleValues9thRow[Math.floor(Math.random() * xPossibleValues9thRow.length)];
        var box = new THREE.Mesh(boxGeometry, boxMaterial);
        var edges = new THREE.EdgesGeometry(boxGeometry);
        var line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color: 0xFFD700}));
        box.position.set(itemX, 5, 135);
        line.position.set(itemX, 5, 135);
        for( var i = 0; i < xPossibleValues9thRow.length; i++){ 
            if ( xPossibleValues9thRow[i] === itemX) { 
                xPossibleValues9thRow.splice(i, 1); 
                i--; 
            }
        }
        maze.add(box);
        maze.add(line);
    }

    var xPossibleValues10thRow = [-45, -35, -25, -15, 15, 25, 35, 45];
    // 10th row
    var count = 0;
    while (count < 8) {
        var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
        var boxMaterial = new THREE.MeshBasicMaterial( {color: 0x0B5345} );
        var itemX = xPossibleValues10thRow[Math.floor(Math.random() * xPossibleValues10thRow.length)];
        var box = new THREE.Mesh(boxGeometry, boxMaterial);
        var edges = new THREE.EdgesGeometry(boxGeometry);
        var line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color: 0xFFD700}));
        box.position.set(itemX, 5, 145);
        line.position.set(itemX, 5, 145);
        for( var i = 0; i < xPossibleValues10thRow.length; i++){ 
            if ( xPossibleValues10thRow[i] === itemX) { 
                xPossibleValues10thRow.splice(i, 1); 
                i--; 
            }
        }
        maze.add(box);
        maze.add(line);
        count = count + 1;
    }

    maze.add(plane1);

    return maze;
}

function createCelticCross() {
    var cross = new THREE.Group();
    cross.position.set(0, 20, 0);

    // circle
    var circleRadius =  7.5;  
    var circleTubeRadius =  2.0;  
    var circleRadialSegments = 30;  
    var circleTubularSegments = 100;  

    var circleGeometry = new THREE.TorusGeometry(circleRadius, circleTubeRadius, circleRadialSegments, circleTubularSegments);;
    var crossMaterial = new THREE.MeshBasicMaterial({color: 0x49311d});
    var circle = new THREE.Mesh(circleGeometry, crossMaterial);
    circle.position.y = 36;
    cross.add(circle);

    // cross in the middle
    var middleCrossShape = new THREE.Shape();
    middleCrossShape.moveTo(-2, 0);
    middleCrossShape.lineTo(2, 0);
    middleCrossShape.lineTo(4, 5);
    middleCrossShape.lineTo(-4, 5);
    middleCrossShape.lineTo(-2, 0);

    var middleCrossSettings = {
        steps: 2,
        depth: 2,
        bevelEnabled: false,
        bevelThickness: 1,
        bevelSize: 1,
        bevelOffset: 0,
        bevelSegments: 1
    };

    var middleCrossGeometry = new THREE.ExtrudeGeometry(middleCrossShape, middleCrossSettings);
    var middleCross1 = new THREE.Mesh(middleCrossGeometry, crossMaterial);
    middleCross1.scale.set(0.7, 1, 1);
    middleCross1.position.y = 1;
    var middleCross2 = new THREE.Mesh(middleCrossGeometry, crossMaterial);
    middleCross2.scale.set(0.7, 1, 1);
    middleCross2.position.x = -1;
    var middleCross3 = new THREE.Mesh(middleCrossGeometry, crossMaterial);
    middleCross3.scale.set(0.7, 1, 1);
    middleCross3.position.y = -1;
    var middleCross4 = new THREE.Mesh(middleCrossGeometry, crossMaterial);
    middleCross4.scale.set(0.7, 1, 1);
    middleCross4.position.x = 1;
    var middleCross5 = new THREE.Mesh(middleCrossGeometry, crossMaterial);
    middleCross5.scale.set(0.4, 0.7, 1);
    middleCross5.position.y = -1.7;

    middleCross2.rotation.z = Math.PI/2;
    middleCross3.rotation.z = Math.PI;
    middleCross4.rotation.z = -Math.PI/2;

    var middleCross = new THREE.Group();
    middleCross.position.y = 36;
    middleCross.add(middleCross1);
    middleCross.add(middleCross2);
    middleCross.add(middleCross3);
    middleCross.add(middleCross4);
    middleCross.add(middleCross5);

    cross.add(middleCross);

    // base
    var baseShape = new THREE.Shape();
    baseShape.moveTo(-2, 0);
    baseShape.lineTo(2, 0);
    baseShape.bezierCurveTo(1.8, 3, 1.5, 5, 1, 8);
    baseShape.lineTo(-1, 8);
    baseShape.bezierCurveTo(-1.5, 5, -1.8, 3, -2, 0);

    var baseGeometry = new THREE.ExtrudeGeometry(baseShape, middleCrossSettings);
    var base = new THREE.Mesh(baseGeometry, crossMaterial);
    base.position.set(0, -20, -1);
    base.scale.set(2.5, 6, 1);

    cross.add(base);

    // top (reusing base and scale it)
    var top = new THREE.Mesh(baseGeometry, crossMaterial);
    top.rotation.z = Math.PI;
    top.position.y = 50;
    top.scale.set(1.5, 2, 1);

    cross.add(top);
    

    return cross;
}

function randomIntFromInterval(min, max) { // min and max included 
  return Math.floor(Math.random() * (max - min + 1) + min);
}

function createRain(min, max) {
    var rainElements = new THREE.Group();
    for (var i = 1; i < 1250 ; i++) {
        var rainGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
        //var rainMaterial = new THREE.MeshBasicMaterial({color: 0xffff00});
        var rainMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
        var rain = new THREE.Mesh(rainGeometry, rainMaterial);
        rain.position.set(randomIntFromInterval(min, max), randomIntFromInterval(1, 60), randomIntFromInterval(min, max));
        rainElements.add(rain);
    }
    return rainElements;
}

function createFire() {
    var fireElements = new THREE.Group();
    for (var i = 0; i < 100; i++) {
        var fireGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        var fireMaterial = new THREE.MeshBasicMaterial({color: 0xff7700});
        var fire = new THREE.Mesh(fireGeometry, fireMaterial);
        fire.position.set(randomIntFromInterval(0, 12), randomIntFromInterval(1, 45), 2);
        fireElements.add(fire);
        
        if (i>=50) {
            fire.visible = false;
        }
        
    }
    return fireElements;
}
        
    var existingZeroTwoObjects = [];
    var removedZeroTwoObjects = [];

        // Create and insert in the scene graph the models of the 3D scene
    function load3DObjects(sceneGraph) {

            // ************************** //
            // Create a ground plane
            // ************************** //

        const pgeometry = new THREE.PlaneGeometry( 100, 100, 32 );
        const pmaterial = new THREE.MeshPhongMaterial( {color: 0x567d46, side: THREE.DoubleSide} );
        const plane = new THREE.Mesh(pgeometry, pmaterial);
        plane.rotation.x = Math.PI / 2;
        plane.receiveShadow = true;
        sceneGraph.add(plane);

        var axes = new THREE.AxisHelper(500);  
        sceneGraph.add(axes);

        var stone1 = makeStone();
        stone1.castShadow = true;
        var center1 = new THREE.Object3D();
        center1.name = "center1";
        center1.add(stone1);
        sceneGraph.add(center1);
        stone1.position.x = 30;

        var stone2 = makeStone();
        var center2 = new THREE.Object3D();
        center2.name = "center2";
        center2.add(stone2);
        sceneGraph.add(center2);
        stone2.position.x = -30;

        var stone3 = makeStone();
        var center3 = new THREE.Object3D();
        center3.name = "center3";
        center3.add(stone3);
        sceneGraph.add(center3);
        stone3.position.z = 30;

        var stone4 = makeStone();
        var center4 = new THREE.Object3D();
        center4.name = "center4";
        center4.add(stone4);
        sceneGraph.add(center4);
        stone4.position.z = -30;

        // Rotated stones (midpoints)
        for (var i = 5; i < 9; i++) {
            var stone = makeStone();
            stone.name = "stone" + i;
            var center = new THREE.Object3D();
            center.name = "center" + i;
            center.add(stone);
            sceneGraph.add(center);
            //stone.position.x = 30;
            stone.position.set(30*Math.cos(Math.PI/4 + i*(Math.PI/2)), 0, 30*Math.sin(Math.PI/4 + i*(Math.PI/2)))
            //center.rotation.y = Math.PI/4 + i*(Math.PI/2);
        }
    



        var center = new THREE.Object3D();
        center.name = "center";

    for (var i=0; i<100; i++) {
        var piece = createPiece(0x00472a);
        center.add(piece);
        piece.position.y = 1;
        piece.position.x = Math.cos(1 + i*0.1);
        piece.position.z = Math.sin(1 + i*0.1);
    }
    var randomNumber = Math.random();
    for (var i=0; i<100; i++) {
        var piece = createPiece(0x00472a);
        //piece.scale.set(0.5,0.5,0.5);
        center.add(piece);
        piece.position.y = 2;
        piece.position.x = Math.cos(1 + i*0.1)/1.1;
        //piece.rotation.y = Math.PI * randomNumber;
        piece.position.z = Math.sin(1 + i*0.1)/1.1;
    }

    var randomNumber = Math.random();
    for (var i=0; i<100; i++) {
        var piece = createPiece(0x00472a);
        //piece.scale.set(0.5,0.5,0.5);
        center.add(piece);
        piece.position.y = 3;
        piece.position.x = Math.cos(1 + i*0.1)/1.2;
        //piece.rotation.y = Math.PI * randomNumber;
        piece.position.z = Math.sin(1 + i*0.1)/1.2;
    }
    var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
    var randomNumber = Math.random();
    for (var i=0; i<100; i++) {
        var piece = createPiece(0x00472a);
        //piece.scale.set(0.5,0.5,0.5);
        center.add(piece);
        piece.position.y = 4;
        piece.position.x = Math.cos(1 + i*0.1)/1.3;
        //piece.rotation.y = Math.PI * randomNumber;
        piece.position.z = Math.sin(1 + i*0.1)/1.3;
    }
    var randomNumber = Math.random();
    for (var i=0; i<400; i++) {
        var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
        var piece = createPiece(randomColor);
        piece.scale.set(1.3, 1.3, 1.3);
        center.add(piece);
        piece.position.y = 5.2;
        //piece.position.x = Math.cos(i)/3;
        piece.rotation.y = THREE.Math.degToRad(i);
        //piece.position.z = Math.sin(i)/3;
    }

    center.position.set(-45, 0, -45);
    center.scale.set(2, 2 , 2);

    /*
    var lathe1 = createLathe(0x000000);
    sceneGraph.add(lathe1);
    lathe1.position.x = -2;
    lathe1.position.y = 10;
    lathe1.name = "lathe1";
    */

    // Make zero two character

    var zerotwoOriginal = createZeroTwo();
    // sceneGraph.add(zerotwoOriginal);
    zerotwoOriginal.position.set(100, 0, 0);
    zerotwoOriginal.name = "zerotwoOriginal";

    // Create and rotate zero twos
    for (var i = 1; i < 9; i++) {
        var zerotwo = createZeroTwo();
        var rotateZeroTwo = new THREE.Object3D();

        rotateZeroTwo.add(zerotwo);

        zerotwo.scale.set(0.2, 0.2, 0.2);
        zerotwo.position.set(20, 13.5, 0);

        zerotwo.name = "zerotwo" + i;
        rotateZeroTwo.name = "rotateZeroTwo" + i;

        rotateZeroTwo.rotation.y = i*(Math.PI/4);
        sceneGraph.add(rotateZeroTwo);

        existingZeroTwoObjects.push(rotateZeroTwo);
    }
    //var centerZeroTwo2 = new THREE.Object3D();
    //centerZeroTwo2.position.set(0, 0, 5);
    //centerZeroTwo2.add(zerotwo2);

    //sceneGraph.add(centerZeroTwo2);
    //centerZeroTwo2.name = "centerzerotwo2";




    /*
        NICE IDEA TO MAKE A NEW KIND OF TREE!! :)
    for (var i=0; i<100; i++) {
        var piece = createPiece(0x000000);
        //piece.scale.set(0.5,0.5,0.5);
        center.add(piece);
        piece.position.y = 4;
        piece.position.x = Math.cos(1 + i*0.1)/1.3;
        piece.rotation.y = Math.PI * Math.random() * 10;
        piece.position.z = Math.sin(1 + i*0.1)/1.3;
    }
    */


    sceneGraph.add(center);

    // Create Mazes
    for (var m = 0; m < 4; m++) {
        var maze = createMaze();
        var mazeObject = new THREE.Object3D();
        mazeObject.add(maze);
        mazeObject.rotation.y = Math.PI/2 * m;
        sceneGraph.add(mazeObject);
    }

    // Create object to move around the maze
    var cylinderTop =  1.5;  
    var cylinderBottom =  1.5;  
    var cylinderHeight = 5;  
    var cylinderSegments = 12;  
    var cylinderGeometry = new THREE.CylinderGeometry(cylinderTop, cylinderBottom, cylinderHeight, cylinderSegments);

    for (var j = 1; j < 5; j++) {
        var randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
        var cylinderMaterial = new THREE.MeshBasicMaterial({color: randomColor});
        var cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
        cylinder.position.set(0, 2.5, 148);
        cylinder.name = "cylinder" + i;
        var cylinderObject3D = new THREE.Object3D();
        cylinderObject3D.add(cylinder);
        sceneGraph.add(cylinderObject3D);
        cylinderObject3D.rotation.y = Math.PI/2 * j;
        cylinderObject3D.name = "cylinderObject3D" + j;
    }

    // Create celtic cross in the middle of the scene
    var cross1 = createCelticCross();
    sceneGraph.add(cross1);

    // Create rain

    for (var j = 1; j < 5; j++) {
        var bigRain = createRain(1, 150);
        var rainObject3D = new THREE.Object3D();
        rainObject3D.add(bigRain);
        sceneGraph.add(rainObject3D);
        rainObject3D.name = "rainObject3D" + j;
        rainObject3D.rotation.y = (i-1) * Math.PI/2;
        console.log(rainObject3D.name);
    }

    // Create fire
    for (var f = 1; f < 5; f++) {
        var fireObject = new THREE.Object3D();
        fireObject.name = "fireObject" + f;
        var fire = createFire();
        fire.position.set(-6, 0, 6);
        fire.name = "fire" + f;
        sceneGraph.add(fireObject);
        fireObject.add(fire);
        fireObject.rotation.y = f * Math.PI/2;
    }

}
    

        // ANIMATING
        // Displacement value

        var delta = 0.1;

        var dispX = 0.2, dispZ = 0.2;

        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2(0.01, 0.01);

        //var quaternion = new THREE.Quaternion().setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI / 2 );
        var countSpeed = 0;
        var countReduceSpeed = 0.01;

        function computeFrame(time) {

            // Animate rain
            

        var bigRain1 = sceneElements.sceneGraph.getObjectByName("rainObject3D1").children[0];
        var rainElementsArray = bigRain1.children;
        for (var j = 0; j < rainElementsArray.length; j++) {
            var element = rainElementsArray[j];
            if (element.position.y > -1) {
                element.position.y -= 0.2;
            } else {
                element.position.y = 65;
            }  
        }
        
        var bigRain1 = sceneElements.sceneGraph.getObjectByName("rainObject3D2").children[0];
        bigRain1.rotation.y = Math.PI/2;
        var rainElementsArray = bigRain1.children;
        for (var j = 0; j < rainElementsArray.length; j++) {
            var element = rainElementsArray[j];
            if (element.position.y > -1) {
                element.position.y -= 0.2;
            } else {
                element.position.y = 65;
            }  
        }

        var bigRain1 = sceneElements.sceneGraph.getObjectByName("rainObject3D3").children[0];
        bigRain1.rotation.y = Math.PI;
        var rainElementsArray = bigRain1.children;
        for (var j = 0; j < rainElementsArray.length; j++) {
            var element = rainElementsArray[j];
            if (element.position.y > -1) {
                element.position.y -= 0.2;
            } else {
                element.position.y = 65;
            }  
        }

        var bigRain1 = sceneElements.sceneGraph.getObjectByName("rainObject3D4").children[0];
        bigRain1.rotation.y = 3*Math.PI/2;
        var rainElementsArray = bigRain1.children;
        for (var j = 0; j < rainElementsArray.length; j++) {
            var element = rainElementsArray[j];
            if (element.position.y > -1) {
                element.position.y -= 0.2;
            } else {
                element.position.y = 65;
            }  
        }

        // Animate fire (at the center)

        for (var f = 1; f < 5; f++) {
            var fire1 = sceneElements.sceneGraph.getObjectByName("fireObject" + f).children[0];
            var fireElementsArray = fire1.children;
            for (var j = 0; j < fireElementsArray.length; j++) {
                var fireElement = fireElementsArray[j];
                if (fireElement.visible == true) {
                    fireElement.visible = false;
                } else {
                    fireElement.visible = true;
                }
            }
        }


            /*
            var lathe1 = sceneElements.sceneGraph.getObjectByName("lathe1");
            lathe1.rotation.y += 0.05;
            */


            // dynamically remove zero twos
            if (keyMinus && existingZeroTwoObjects.length > 0) {
                var randomItem = existingZeroTwoObjects[existingZeroTwoObjects.length - 1];
                removedZeroTwoObjects.push(randomItem);
                sceneElements.sceneGraph.remove(randomItem);
                existingZeroTwoObjects.pop(randomItem);
            }

            else if (keyPlus && existingZeroTwoObjects.length <=8 && removedZeroTwoObjects.length != 0) {
                var object = removedZeroTwoObjects[removedZeroTwoObjects.length - 1];
                sceneElements.sceneGraph.add(object);
                removedZeroTwoObjects.pop(object);
                existingZeroTwoObjects.push(object);
            }
            
             // rotate zero twos
            if (!keyAlt && !keyAltGr) {
                for (var i=0; i<existingZeroTwoObjects.length; i++) {
                var zerotwoObject = sceneElements.sceneGraph.getObjectByName(existingZeroTwoObjects[i].name);
                zerotwoObject.rotation.y -= 0.02;
                var zerotwo = zerotwoObject.children[0];
                zerotwo.rotation.y -= 0.1;
                }
            } else if (keyAlt) {
                keyAltGr = false;
                for (var i=0; i<existingZeroTwoObjects.length; i++) {
                    var zerotwoObject = sceneElements.sceneGraph.getObjectByName(existingZeroTwoObjects[i].name);
                    zerotwoObject.rotation.y -= 0.06;
                    var zerotwo = zerotwoObject.children[0];
                    zerotwo.rotation.y -= 0.3;
                } 
            } 
            else if (keyAltGr) {
                for (var i=0; i<existingZeroTwoObjects.length; i++) {
                    var zerotwoObject = sceneElements.sceneGraph.getObjectByName(existingZeroTwoObjects[i].name);
                    zerotwoObject.rotation.y += 0.04;
                    var zerotwo = zerotwoObject.children[0];
                    zerotwo.rotation.y += 0.2;
                }
            } 

             // upgrade speed of zero two's rotations

            if (keyP) {
                for (var i=0; i<existingZeroTwoObjects.length; i++) {
                    var zerotwoObject = sceneElements.sceneGraph.getObjectByName(existingZeroTwoObjects[i].name);
                    zerotwoObject.rotation.y -= 0.01 * countSpeed;
                    var zerotwo = zerotwoObject.children[0];
                    zerotwo.rotation.y -= 0.05 * countSpeed;
                }
                countSpeed = countSpeed + 1;
             }

             else if (keyM) {
                for (var i=0; i<existingZeroTwoObjects.length; i++) {
                    var zerotwoObject = sceneElements.sceneGraph.getObjectByName(existingZeroTwoObjects[i].name);
                    zerotwoObject.rotation.y -= countReduceSpeed/100;
                    var zerotwo = zerotwoObject.children[0];
                    zerotwo.rotation.y -= countReduceSpeed/100;
                }
                countReduceSpeed = countReduceSpeed/4;
             } 

            // make each zero two turn into a stone when pressing Shift
            if (keyShift) {
                var stoneNumber = 1;
                for (var z2 = 0; z2 < existingZeroTwoObjects.length; z2++) {
                    var zerotwoObject = sceneElements.sceneGraph.getObjectByName(existingZeroTwoObjects[z2].name);
                    var stone = sceneElements.sceneGraph.getObjectByName("center" + stoneNumber).children[0];
                    zerotwoObject.position.set(stone.position.x, 0, stone.position.z);
                    var zerotwo = zerotwoObject.children[0];
                    zerotwo.position.set(8.5, 13.5, 0);
                    stoneNumber++;
                }
            }

            else  if (keyEnter) {
                for (var z2=0; z2<existingZeroTwoObjects.length; z2++) {
                    var zerotwoObject = sceneElements.sceneGraph.getObjectByName(existingZeroTwoObjects[z2].name);
                    zerotwoObject.position.set(0, 0, 0);
                    var zerotwo = zerotwoObject.children[0];
                    zerotwo.position.set(20, 13.5, 0);
                }
             }

            /*
            var zerotwo2 = sceneElements.sceneGraph.getObjectByName("zerotwo2");
            zerotwo2.rotation.y += 0.05;
            */

    // Change color of tree when mouse hover
    raycaster.setFromCamera( mouse, sceneElements.camera );
    
    // calculate objects intersecting the picking ray
    var array = sceneElements.sceneGraph.getObjectByName("center").children;
    
    // for (var i = 0; i < array.length; )

    var intersects = raycaster.intersectObjects( sceneElements.sceneGraph.getObjectByName("center").children);        

    if ( intersects.length > 0 && array.includes(intersects[0].object)) {
        intersects[0].object.material.color.set(0xadff2f);
        
    
    } else {
        for (var k = 0; k < array.length; k++) {
            array[k].material.color.set( 0x00472a);
        }
        
    
    }

    // change size of stones when hover
    for (var i=1; i<9; i++) {
        var arrayStone = sceneElements.sceneGraph.getObjectByName("center" + i).children;
        var intersectsStone = raycaster.intersectObjects( sceneElements.sceneGraph.getObjectByName("center" + i).children);
        
        if (intersectsStone.length > 0 && arrayStone.includes(intersectsStone[0].object) && intersectsStone[0].object.scale.y <= 1.7) {
            intersectsStone[0].object.scale.y += 0.2;
        } else if (intersectsStone.length > 0 && arrayStone.includes(intersectsStone[0].object) && intersectsStone[0].object.scale.y > 1.7) {
            intersectsStone[0].object.scale.y = 2.0;
        } else {
            for (var k=0; k<arrayStone.length; k++) {
                arrayStone[k].scale.set(1, 1, 1);
            }
            
        }
    }

    // move cylinder with arrows

    var cylinderArray1 = sceneElements.sceneGraph.getObjectByName("cylinderObject3D1").children;
    var cylinder1 = cylinderArray1[0];

    var cylinderArray2 = sceneElements.sceneGraph.getObjectByName("cylinderObject3D2").children;
    var cylinder2 = cylinderArray2[0];

    var cylinderArray3 = sceneElements.sceneGraph.getObjectByName("cylinderObject3D3").children;
    var cylinder3 = cylinderArray3[0];

    var cylinderArray4 = sceneElements.sceneGraph.getObjectByName("cylinderObject3D4").children;
    var cylinder4 = cylinderArray4[0];

    if (keyArrowUp && cylinder4.position.z >= 52) {
        cylinder4.position.z -= 1;
        cylinder1.position.z -= 1;
        cylinder2.position.z -= 1;
        cylinder3.position.z -= 1;
    }
    if (keyArrowDown && cylinder4.position.z <= 145) {
        cylinder4.position.z += 1;
        cylinder1.position.z += 1;
        cylinder2.position.z += 1;
        cylinder3.position.z += 1;
    }

    if (keyArrowLeft && cylinder4.position.x >= -48) {
        cylinder4.position.x -= 1;
        cylinder1.position.x -= 1;
        cylinder2.position.x -= 1;
        cylinder3.position.x -= 1;
    }

    if (keyArrowRight && cylinder4.position.x <= 48) {
        cylinder4.position.x += 1;
        cylinder1.position.x += 1;
        cylinder2.position.x += 1;
        cylinder3.position.x += 1;
    }
        

            // Rendering
            helper.render(sceneElements);

            // NEW --- Update control of the camera
            sceneElements.control.update();

            // Call for the next frame
            requestAnimationFrame(computeFrame);
        }

        // STARTING

        init();

    </script>



</head>

<body>
    <audio id="player" autoplay loop>
        <source src="resources/danceOfTheDruids.mp3" type="audio/mp3">
    </audio>
    <div id="Tag3DScene"> </div>
</body>
</html>